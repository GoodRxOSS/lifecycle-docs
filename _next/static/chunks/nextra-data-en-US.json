{"/articles/introduction":{"title":"Introducing Lifecycle","data":{"":"We started building Lifecycle at GoodRx in 2019 because managing our lower environments like staging, development, QA had become a daily headache. As our architecture shifted from a monolith to microservices, our internal channels were flooded with messages like \"Is anyone using staging?\" \"Staging is broken again,\" and \"Who just overwrote my changes?\" Waiting in line for hours (sometimes days) to test code in a real-world-like environment was the norm.We simply couldn't scale with our engineering growth. So, as a proof of concept, we spun up Lifecycle: a tool that lets you create on-demand, ephemeral environments off of github pull request.At first, only a handful of services were onboarded, but our engineers immediately saw the difference, no more static staging servers, no more pipeline gymnastics, and no more accidental overwrites. They wanted Lifecycle wherever they touched code, so we built a simple lifecycle.yaml configuration, replaced our manual database entries, and baked Lifecycle support into every new service template. Before long.After ironing out early scaling kinks, we realized Lifecycle had become more than an internal convenience, it was a game-changer for us.Today (June 5, 2025), we're thrilled to open-source five years of collective effort under the Apache 2.0 license. This project represents countless late-night brainstorming sessions, pull requests, and \"aha\" moments, and we can't wait to see how you'll make it your own: adding integrations, optimizing performance, or finding novel workflows we never imagined.By sharing Lifecycle, we hope to help teams stuck in the same limited environment limbo we once were and build a community of passionate likeminded developers who'll shape the the future of Lifecycle.We look forward to learning from you, growing together, and making shipping high-quality software faster and more enjoyable for everyone!Join our Discord server here to connect!!"}},"/docs/features/auto-deployment":{"title":"Auto Deploy & Labels","data":{"auto-deploy-configuration#Auto-Deploy Configuration":"To enable automatic deployment when a PR is created, set the autoDeploy attribute in your repository's lifecycle.yaml file:\nLifecycle will automatically create the environment as soon as a PR is opened.\nA lifecycle-deploy! label will be added to the PR to indicate that the environment has been deployed.","managing-deployments-with-labels#Managing Deployments with Labels":"If auto-deploy is not enabled, you can manually control the environment using PR labels.","deploy-an-environment#Deploy an Environment":"To create an ephemeral environment for a PR, add the lifecycle-deploy! label.","tear-down-an-environment#Tear Down an Environment":"To delete an active environment, use either of these labels:\nRemove lifecycle-deploy!\nAdd lifecycle-disabled!","automatic-cleanup-on-pr-closure#Automatic Cleanup on PR Closure":"When a PR is closed, Lifecycle will:\nTear down the active environment.\nRemove the lifecycle-deploy! label from the PR.\nThis ensures that unused environments do not persist after the PR lifecycle is complete.","summary#Summary":"Feature\tBehavior\tautoDeploy: true in config\tPR environments are automatically deployed.\tlifecycle-deploy!\tManually deploy an environment.\tRemove lifecycle-deploy!\tTear down the environment.\tAdd lifecycle-disabled!\tTear down the environment manually.\tPR closed\tEnvironment is deleted automatically.\t\nUsing these configurations and labels, teams can efficiently manage ephemeral environments in their development workflow."}},"/docs/features/service-dependencies":{"title":"Service Dependencies","data":{"":"This document will cover environment.{defaultServices,optionalServices} and service.requires, their differences, impact scope, and usage.","environmentdefaultservicesoptionalservices#environment.{defaultServices,optionalServices}":"","impact-scope#Impact scope":"Scope\tImpact\tService repo*\t✅\tOutside repo*\t❌\tdev-0*\t❌\t\nThis represents the default environment that will be created by lifecycle when a pull request is opened in the service repo* and does not have any impact on outside repos, dev-0, or any other static environments that use this service.","servicesrequires#services.requires":"","impact-scope-1#Impact scope":"Scope\tImpact\tService repo*\t✅\tOutside repo*\t✅\tdev-0*\t✅\t\nservices.requires has an impact across the board; hence, it is important to understand how it works and when we should use them.Please read the info blocks below carefully.You can think of services.requires as a hard dependency definition. For example, if you have an API service and a database, the API service will have a hard dependency on the database.\nIn this scenario, the database should not be defined as the default service. Instead, we should make the dependency explicitly clear by adding the database to the API’s requires block.\nBy doing this, we ensure that any outside repo that wants to use our API service will get the database along with it but only needs to specify the API service in their defaultServices or optionalServices.\nOnly services defined in lifecycle.yaml should be used in the requires\narray. If a service is defined in an outside repo, use\nenvironment.defaultServices instead.\nDo not use services in the services.requires if the service itself is not\ndefined in the same lifecycle.yaml.\nServices defined in the requires block will only be resolved 1 level down.\nThis is a very important nuance, which we get tripped by regularly.","examples#Examples":"To better illustrate the above statement, consider this example.Repository A r-A has 3 services s-A, s-B, and s-C.\ns-A requires s-B.\ns-B requires s-C.\nAs you can see, s-A has an indirect dependency on s-C through s-B.","scenario-1-pull-request-in-service-repo-#Scenario 1: Pull Request in Service repo* ✅":"When we open a pull request in r-A repo, lifecycle will deploy 3 services: s-A, s-B, and s-C.","breakdown#Breakdown":"Lifecycle deploys s-A and s-B because they are defined in defaultServices.\nServices defined in the requires block will only be resolved one level down.\nOnly services defined in lifecycle.yaml should be used in the requires array. If a service is defined in an outside repo, use environment.defaultServices instead.","scenario-2-#Scenario 2: ❌":"Repository B r-B has service s-X and also defines an outside repo r-A service s-A as environment.defaultServices.","breakdown-1#Breakdown":"Lifecycle deploys s-X and s-A because they are defined in defaultServices.\nLifecycle deploys s-B because it is a 1st level dependency of a service (s-A) listed in defaultServices.\nLifecycle does not deploy s-C since it is not a 1st level dependency of any service listed in defaultServices or optionalServices.\nThe way this scenario manifests is lifecycle will deploy s-X, s-A, and s-B, but the build will likely fail because s-B is missing a required dependency s-C.","solutions#Solutions":"There are 2 ways to address this depending on your use case.","solution-1#Solution 1":"Add s-B to r-B’s environment.defaultServices block in r-B.lifecycle.yaml. In effect, this will make s-C a first-level dependency.","solution-2#Solution 2":"Add s-C to the services.requires block of r-A in r-A.lifecycle.yaml. This will also make s-C a first-level dependency.","choosing-the-right-solution#Choosing the Right Solution":"In summary, the solution you should use depends on how you want your service to be consumed in an outside repo*.\nIf you want outside repos to explicitly include s-A and s-B, use Solution 1.\nIf you want outside repos to only include s-A and let dependencies resolve automatically, use Solution 2.","terminology#Terminology":"Service repo: The repository where lifecycle.yaml is defined.\nOutside repo: Another repository referencing it.\ndev-0: Default static environment."}},"/docs/features/template-variables":{"title":"Template Variables","data":{"overview#Overview":"Lifecycle uses Mustache as the template rendering engine.","available-template-variables#Available Template Variables":"The following template variables are available for use within your configuration. Variables related to specific services should use the service name as a prefix.","general-variables#General Variables":"{{{ buildUUID }}} - The unique identifier for the Lifecycle environment, e.g., lively-down-881123.\n{{{ namespace }}} - Namespace for the deployments, e.g., env-lively-down-881123.\n{{{ pullRequestNumber }}} - The GitHub pull request number associated with the environment.","service-specific-variables#Service-Specific Variables":"For service-specific variables, replace <service_name> with the actual service name.\n{{{ <service_name>_internalHostname }}} - The internal hostname of the deployed service. If the service is optional and not deployed, it falls back to defaultInternalHostname.\nservice_internalHostname will be substituted with local cluster full\ndomain name like service.namespace.svc.cluster.local to be able to work\nwith deployments across namespaces.\n{{{ <service_name>_publicUrl }}} - The public URL of the deployed service. If optional and not deployed, it defaults to defaultPublicUrl under the services table.\n{{{ <service_name>_sha }}} - The GitHub SHA that triggered the Lifecycle build.\n{{{ <service_name>_branchName }}} - The branch name of the pull request that deployed the environment.\n{{{ <service_name>_UUID }}} - The build UUID of the service. If listed under optionalServices or defaultServices, its value depends on whether the service is selected:\nIf selected, it is equal to buildUUID.\nIf not selected (or if service not part of deploys created), it defaults to dev-0.","usage-example#Usage Example":"This ensures the PUBLIC_URL and INTERNAL_HOST variables are dynamically assigned based on the ephemeral environment deployment.\nUndefined variables will result in an empty string unless handled explicitly.\nUse triple curly braces ({{{ }}}) to prevent unwanted HTML escaping.\nEnsure service names are correctly referenced in the template.\nFor more details, refer to the Mustache.js documentation."}},"/docs/features/webhooks":{"title":"Webhooks","data":{"":"Lifecycle can invoke third-party services when a build state changes. Currently, only Codefresh pipeline triggers are supported. Webhooks allow users to automate external processes such as running tests or performing cleanup tasks based on environment build states.","common-use-cases#Common Use Cases":"When a build status is deployed, trigger end-to-end tests.\nWhen a build status is error, trigger infrastructure cleanup or alert the team.","webhook-configuration#Webhook Configuration":"Webhooks are defined in the lifecycle.yaml under the environment.webhooks section.Below is an example configuration for triggering end-to-end tests when the deployed state is reached.","examples#Examples":"state: deployed → Triggers the webhook when the build reaches the deployed state.\ntype: codefresh → Specifies that this webhook triggers a Codefresh pipeline.\nname → A human-readable name for the webhook.\npipelineId → The unique Codefresh pipeline ID.\ntrigger → Codefresh pipeline's trigger to execute.\nenv → Passes relevant environment variables (e.g., branch and TEST_URL).\nstate: error → Triggers the webhook when the build fails.\ntype: codefresh → Invokes a Codefresh cleanup pipeline.\ntrigger: cleanup → Codefresh pipeline's trigger to execute.\nenv → Includes necessary variables, such as branch and CLEANUP_TARGET.","limitations#Limitations":"Currently, Lifecycle only supports Codefresh pipeline triggers.\nIn need of support for other webhook types? please submit a pull request or an issue.\nBy leveraging webhooks, teams can automate workflows, run tests, and clean up failed deployments seamlessly within Lifecycle."}},"/docs/getting-started/configure-environment":{"title":"Configure environment","data":{"":"Now that we've created and deployed our first Lifecycle environment, let's learn how to customize it by configuring services and dependencies.","understanding-configuration#Understanding Configuration":"First, let's take a look at the lifecycle.yaml configuration file at the root dir of lifecycle-examples repository:","default-and-optional-services#Default and Optional Services":"We have our dependencies defined in defaultServices and optionalServices:\ndefaultServices – These services are always built and deployed with the environment. They form the core foundation of the environment and are required for it to function correctly.\noptionalServices – These services can be built on demand, only when explicitly needed. If they are not selected during a PR, they default to using a static environment (e.g., dev-0).","template-variables#Template Variables":"Notice how there are template variables defined in service named frontend > github.docker.env:\nThis API_URL and CACHE_URL variables are dynamically templated by Lifecycle and provided during the build and deploy steps for the frontend service.\nRead more about supported template variables\nhere","static-environment-as-a-fallback#Static Environment as a Fallback":"Since cache is an optional service, this service defaulted to using a static environment(dev-0) as a fallback. This allows us to reuse existing environments instead of rebuilding everything from scratch when there are no changes.","check-template-variables#Check Template Variables":"To view how the fallback URL works,\nOpen your Tasks App(frontend) from the deployed environment.\nNavigate to the Variables page.\nSearch for _URL and check its value.\nIt should look like:\nNotice how CACHE_URL defaults to the dev-0(static) environment for the optional cache.","configuring-services#Configuring Services":"Now, let's say you also want to the cache component to test, build and deploy it in your environment.","enable-cache-deployment#Enable Cache Deployment":"Navigate to the Lifecycle PR comment on GitHub.\nSelect the cache checkbox in the comment. That's it!\nLifecycle will now start building and deploying the cache service for your specific environment.\nWait for the build to complete. You can monitor the progress in the status comment.","confirm-the-new-cache-url#Confirm the New Cache URL":"Once the cache is deployed, go back to your frontend app’s Variables page.\nCheck the CACHE_URL value.\nIt should now look like:\nNow, you're running your cache from your own environment instead of an existing static deploy!\nCheck the application’s Tasks page while you’re here and observe the completely different data, as this environment uses a freshly built and seeded database.","build-flexible-environments#Build Flexible Environments":"With this approach, you can:\nBuild any combination of frontend and backend services.\nUse custom branches for different services.\nTest different versions of your app.\nCheck how to use Mission Control comments for configuring your environment\nhere\nThis gives you a custom, isolated testing environment that mirrors your\nproduction setup while allowing flexibility in development and validation.","summary#Summary":"Services marked as optional in lifecycle.yaml will default to static environments unless explicitly built.\nYou can enable/disable any service directly from the Lifecycle PR comment.\nLifecycle automates dependency management, ensuring your services deploy in the correct order.\nNow you're ready to customize your Lifecycle environments like a pro! 👩‍💻"}},"/docs/getting-started/create-environment":{"title":"Create environment","data":{"":"In this walk through, we will make a simple change to an example frontend repository and create our first ephemeral environment using Lifecycle.","1-fork-the-repository#1. Fork the Repository":"Fork the lifecycle-examples repository to your org or personal account and install your newly minted GitHub App to the forked repository.\nNavigate to https://github.com/settings/apps (for personal accounts) or https://github.com/organizations/<org>/settings/apps (for org accounts).\nFind the Lifecycle GitHub App and click on Edit.\nChoose Install App from sidebar and click the Settings  icon.\nSelect the forked repository from the list and select Save.","2-create-a-new-branch#2. Create a New Branch":"Clone the repo and create a branch named lfc-config:\nor if you are using GitHub Desktop, you can create a new branch from the UI.","3-update-lifecycle-configuration#3. Update Lifecycle Configuration":"Open the lifecycle.yaml file in the root of the repository and update the frontend service's repository to your github username or org.Before:\nAfter:","4-commit--push-your-changes#4. Commit & Push Your Changes":"","5-create-a-pull-request#5. Create a Pull Request":"Open a Pull Request (PR) from lfc-config to main in the forked repository.\nSubmit the PR.","6-lifecycle-pr-comment#6. Lifecycle PR Comment":"After submitting the PR, you’ll see a GitHub comment from Lifecycle on your pull request.🔹 This PR comment is the mission control for your ephemeral environment. It provides:\nA status update of the build and deploy process.\nA list of services configured for the environment.\nA link to the Lifecycle UI where you can view logs, deployments, and environment details.\nIf there is no comment from Lifecycle, it means the app is not configured\ncorrectly or the GitHub App is not installed in the repository. Please refer\nto the Missing Comment page for\nmore information.","7-add-lifecycle-status-comments-label#7. Add lifecycle-status-comments! label":"The additional label lifecycle-status-comments! provides more detailed information about the environment status and links to access the running application.🔹 The comments provides insights into:\nBuild & Deploy Status: Track when your environment is ready.\nEnvironment URLs: Access the running frontend app.\nTelemetry Links: Links to telemetry, build and deploy logs. (if enabled)","8-wait-for-deployment#8. Wait for Deployment":"Wait for the builds & deploys to complete. Once the status updates to deployed, your environment is live! 🚀When a new commit is pushed to your pull request Lifecycle automatically builds and deploys again so you always have the latest version of the application.\nIf there are any errors during the build or deploy process, the environment\nwill not be created, and you will see an error message in the Lifecycle\ncomment.\nYou can check the logs from lifecycle-worker pods in your cluster to debug\nthe issue:  kubectl logs deploy/lifecycle-worker -n lifecycle-app -f","9-checkout-the-deployed-application#9. Checkout the deployed application":"Once the deployment is complete, you can access your environment at the URL provided in the Lifecycle comment on your pull request. Click on the frontend link to open your application in a new tab.The application has two simple pages:\n/tasks – A simple to-do list.\n/variables – Displays all environment variables from the container.","next-steps#Next Steps":"Now that your first ephemeral environment is ready, move on to the next section where we:🧪 Test the environment.\n🧭 Explore the comments and logs.\n⚙️ Customize the configuration."}},"/docs/getting-started/delete-environment":{"title":"Delete environment","data":{"":"To tear down an environment, you can do one of the following:\nMerge or close the pull request: This will automatically clean up the environment.\nApply the lifecycle-disabled! label: This will immediately trigger the environment deletion process.\nThe lifecycle-disabled! label is useful in scenarios where:\nThe environment infrastructure is experiencing issues.\nThe data within the environment is corrupt.\nYou need to restart or rebuild the environment from scratch without waiting for a PR to be merged or closed.\nSimply apply the label to the PR associated with the environment, and Lifecycle will automatically tear it down.\nRead more about how pull request labels control auto deploy in repositories\nhere\nUsing these methods, you can efficiently manage and clean up environments to ensure smooth development and testing workflows. 🧹"}},"/docs/getting-started/explore-static-environment":{"title":"Explore static environment","data":{"":"A static environment in Lifecycle is a persistent environment that serves as a fallback when dependent services do not need to be rebuilt.Unlike ephemeral environments that are built on short lived pull requests, static environments are built on top of long lived pull requests. These environments exist continuously and update automatically as changes are merged into the default branch of configured services.","what-is-dev-0#What is dev-0":"The default static environment is dev-0. This environment ensures that there is always a stable and up-to-date version of services available without needing to build every dependency manually.\nThe dev-0 environment should be created for your installation.During the initial bootstrapping of Lifecycle, the dev-0 build record is created automatically but this itself does not have any services built.","create-dev-0#Create dev-0":"Delete the dummy dev-0 build record from builds table in the database\nCreate a repository named lifecycle-static-env in your GitHub account\nInstall the Lifecycle GitHub App in this repository\nCreate a pull request in this repository with branch dev-0\nAdd lifecycle.yaml file to the root of the repository with all the services you want to include in the dev-0 environmentExample:\nDeploy the dev-0 environment by adding lifecycle-deploy! label to the pull request\nUpdate uuid for the environment to dev-0 in the mission control comment\nFinally, execute this query to track default branches of the services in the dev-0 environment:","key-features#Key Features":"🏗️ Fallback for Optional Services\nWhen optional services are not explicitly built in an ephemeral environment, Lifecycle defaults to using the latest build from dev-0.\n💪 Based on a Persistent PR\nSimilar to ephemeral environments, dev-0 is based on a PR, but it remains open and continuously updates.\n👣 Tracks Changes on Default Branch Merges\nWhenever a service has a new change merged to its main branch, dev-0 will automatically pull, build, and redeploy the latest changes.\nThis ensures dev-0 always contains the freshest version of all services."}},"/docs/getting-started/explore-environment":{"title":"Explore environment","data":{"":"Now that we've deployed our first Lifecycle environment, let’s take a tour of the PR comments to understand how to interact with our ephemeral environment.","test-your-application#Test Your Application":"Let's navigate to the deployed frontend app from the PR comment.\nClick on the frontend link in the PR comment to navigate to your deployed application.\nAdd a task and complete few tasks to update data in backend.\nNavigate to the variables page and checkout the variables in your application's container.\nThats it! You have successfully deployed and tested the best todo app in the world! 🎉","mission-control-comment#Mission Control Comment":"The Lifecycle PR comment in your pull request serves as the mission control for your ephemeral environment.","what-you-can-do-in-the-pr-comment#What You Can Do in the PR Comment":"Editable Checkboxes: Select or deselect services to include in your environment.\nRedeploy Checkbox: Triggers a redeploy (useful for transient issues).\nDeployment Section: Provides URLs to your deployed services.\nRead more about Mission Control comment\nhere","status-comment#Status Comment":"When we add the lifecycle-status-comments! label to our pull request, Lifecycle will automatically add a status comment to the PR.This comment provides real-time updates on the status, links to your deployments including the build progress and service statuses.\nNotice the following while the environment is being built:\nThe status comment is updated in real-time.\nThe status of each service is displayed.\nThe build logs are available for each service.","next-steps#Next Steps":"In the next section, we will:⚙️ Customize our configuration\n☑️ Enable and build an optional service(cache) support your applicationReady to level up your ephemeral environment? Let's go! 🏃‍➡️"}},"/docs/getting-started/terminology":{"title":"Terminology","data":{"":"This glossary provides an overview of key Lifecycle concepts and terminology. Let's see how they fit into the environment setup and deployment process.","repository#Repository":"A repository refers to a GitHub repository. Each environment that is built must have a default repository and an associated pull request.","service#Service":"A service is a deployable artifact. It can be a Docker container, CI pipeline, RDS database, or Helm chart. A single repository can contain multiple services.Example: \nfrontend-service and frontend-cache are two services required for the frontend application to function correctly.","environment#Environment":"An environment is a stack of services built and connected together.\ndefaultServices are built and deployed in an environment by default.\noptionalServices can be built and deployed only when needed; otherwise, they fallback to the default static environment.","static-environment#Static Environment":"A static environment is a long-lived environment based on a pull request. It tracks branches from configured services and updates automatically when new changes are merged.","build#Build":"A build is the actual instance of the process to build and deploy services within an environment.\nEach build is uniquely identified by Lifecycle using a UUID (e.g., arm-model-060825 or dev-0).\nA build contains one deploy per service in the configuration.","deploy#Deploy":"A deploy manages the build and deployment execution of a service within an environment.Example:\nIn a frontend environment, frontend-service and frontend-cache are two deploys created for the environment, each mapped to a unique build UUID.","webhook#Webhook":"Lifecycle can invoke third-party services when a build state changes. Currently, only Codefresh triggers are supported.","example#Example":"When the build status is deployed, trigger end-to-end tests.\nWhen the build status is error, trigger infrastructure cleanup."}},"/docs/schema/full":{"title":"Lifecycle Full Schema","data":{"full-lifecycle-schema#Full Lifecycle Schema":"Below is the full Lifecycle schema as defined in the lifecycle.yaml file with basic comments for each item."}},"/docs/schema":{"title":"Lifecycle Schema","data":{"":"The Following document covers the Lifecycle schema and how to use it.\nOur goal is to take all of the information about the Lifecycle schema and put it here so that you can find and share everything you need easily.\nFeedback is appreciated if this is not the case.","lifecycle-schema-breakdown#Lifecycle Schema Breakdown":"The Lifecycle schema is defined via the lifecycle.yaml file, which is used to define the environment and services that will be deployed in the Lifecycle environment.\nIn this section, we will break down the schema into sections and provide examples of how to use each section.","environment#environment":"The environment object is the most important object within the lifecycle.yaml schema.\nIt contains a few key values pairs and, currently, 2 main objects, defaultServices and optionalServices.","environmenttypes#environmentTypes":"Each service object within the services array defines a service that can deployed in the Lifecycle environment.\nIf the service is defined within the lifecycle.yaml, it does not require all object properties to be defined; only its name.\nIf the service is defined outside of the lifecycle.yaml, it requires all properties to be defined.","defaultservices#defaultServices":"The environment.defaultServices array defines services that are always deployed by default when the Lifecycle environment is deployed.","optionalservices#optionalServices":"environment.optionalServices services is an array of services objects that contains all services that may be deployed in the Lifecycle environment.","services#services":"The services object is an array of objects with child objects and properties describing the services created from this Lifecycle project.\nAs of right now, OSS Lifecycle supports 2 types of services, github and docker.","docker#docker":"The docker service type is used to define a Docker service that can be deployed in the Lifecycle environment.","properties#properties":"This section describes properties and *simple objects, eg env, that are used to define a Lifecycle Docker service.\n*Simple Objects: more complex objects are described in their own sections below.\ndockerImage: The Docker image to use for the service.\ndefaultTag: The default tag to use for the Docker image.\ncommand: The command to run in the Docker container.\narguments: Stringified arguments to pass to the command.\nenv: An key value pair object containing environment variables to set in the Docker container.\nports: A list of ports to expose in the Docker container.","deployment#deployment":"docker.deployment: The deployment configuration for the Docker service.\ndeployment.public: If true, the service will be publicly accessible.\ndeployment.capacityType: The capacity type to use for the service.\ndeployment.resource: The resource requirements for the service.\ndeployment.resource.cpu.request: The CPU request for the service.\ndeployment.resource.cpu.limit: The CPU limit for the service.\ndeployment.resource.memory.request: The memory request for the service.\ndeployment.resource.memory.limit: The memory limit for the service.\ndeployment.hostnames: The hostnames for the service.\ndeployment.hostnames.host: The hostname for the service.\ndeployment.hostnames.acmARN: The ACM ARN for the service.\ndeployment.hostnames.defaultInternalHostname: The default internal hostname for the service.\ndeployment.hostnames.defaultPublicUrl: The default public URL for the service.","helm#helm":"deployment.helm: The Helm configuration for the Docker service.\ndeployment.helm.enabled: If true, Helm will be used to deploy the service.\ndeployment.helm.chartName: The name of the Helm chart to use for the service.\ndeployment.helm.chartRepoUrl: The URL of the Helm chart repository to use for the service.\ndeployment.helm.chartVersion: The version of the Helm chart to use for the service.\ndeployment.helm.cmdPs: The command to run to get the status of the service.\ndeployment.helm.action: The action to perform on the service.\ndeployment.helm.customValues: A list of custom values to pass to the Helm chart.\ndeployment.helm.customValueFiles: A list of custom value files to pass to the Helm chart.\ndeployment.helm.helmVersion: The version of Helm to use for the service.\ndeployment.helm.attachPvc: The PVC configuration for the service.\ndeployment.helm.attachPvc.enabled: If true, a PVC will be attached to the service.\ndeployment.helm.attachPvc.mountPath: The path to mount the PVC to.","readiness#readiness":"deployment.readiness: The readiness configuration for the Docker service.\ndeployment.readiness.disabled: If true, the service will not be ready.\ndeployment.readiness.tcpSocketPort: The port to use for the TCP socket.\ndeployment.readiness.httpGet: The network configuration for the Docker service.\ndeployment.readiness.httpGet.path: The path to use for the HTTP GET request.\ndeployment.readiness.httpGet.port: The port to use for the HTTP GET request.\ndeployment.readiness.initialDelaySeconds: The number of seconds to wait before starting the readiness check.\ndeployment.readiness.periodSeconds: The number of seconds between each readiness check.\ndeployment.readiness.timeoutSeconds: The number of seconds to wait for a readiness check to complete.\ndeployment.readiness.successThreshold: The number of consecutive successful readiness checks before considering the service ready.\ndeployment.readiness.failureThreshold: The number of consecutive failed readiness checks before considering the service not ready.","network#network":"deployment.network: The network configuration for the Docker service.\ndeployment.network.ipWhitelist: A list of IP addresses to whitelist for the service.\ndeployment.network.pathPortMapping: A mapping of paths to ports for the service.\ndeployment.network.hostPortMapping: A mapping of host ports to container ports for the service.\ndeployment.network.grpc: The gRPC configuration for the service.\ndeployment.network.grpc.enable: If true, gRPC will be enabled for the service.\ndeployment.network.grpc.host: The host to use for gRPC.\ndeployment.network.grpc.defaultHost: The default host to use for gRPC.","servicedisks#serviceDisks":"deployment.serviceDisks: A list of service disks to attach to the Docker service.\ndeployment.serviceDisks.name: The name of the service disk.\ndeployment.serviceDisks.mountPath: The path to mount the service disk to.\ndeployment.serviceDisks.accessModes: The access modes for the service disk.\ndeployment.serviceDisks.storageSize: The size of the service disk.\ndeployment.serviceDisks.medium: The medium to use for the service disk.","github#github":"The github service type is used to define a Github service that can be deployed in the Lifecycle environment.","properties-1#properties":"This section describes properties and *simple objects, eg env, that are used to define a Lifecycle Docker service.\n*Simple Objects: more complex objects are described in their own sections below.\nrepository: The repository to use for the service.\nbranchName: The branch name to use for the service.","docker-1#docker":"github.docker: The Docker configuration for the Github service.\ngithub.docker.defaultTag: The default tag to use for the Docker image.\ngithub.docker.builder: The builder to use for the Docker image.\ngithub.docker.builder.engine: The engine to use for the Docker image.\ngithub.docker.app: The application to use for the Docker image.\ngithub.docker.app.dockerfilePath: The path to the Dockerfile to use for the application.\ngithub.docker.app.command: The command to run in the Docker container.\ngithub.docker.app.arguments: Stringified arguments to pass to the command.\ngithub.docker.app.env: An key value pair object containing environment variables to set in the Docker container.\ngithub.docker.app.ports: A list of ports to expose in the Docker container.\ngithub.docker.init: The init configuration for the Docker service.\ngithub.docker.init.dockerfilePath: The path to the Dockerfile to use for the init container.\ngithub.docker.init.command: The command to run in the init container.\ngithub.docker.init.arguments: Stringified arguments to pass to the command.\ngithub.docker.init.env: An key value pair object containing environment variables to set in the init container.","deployment-1#deployment":"github.deployment: The deployment configuration for the Github service.\ngithub.deployment.public: If true, the service will be publicly accessible.\ngithub.deployment.capacityType: The capacity type to use for the service.\ngithub.deployment.resource: The resource requirements for the service.\ngithub.deployment.resource.cpu.request: The CPU request for the service.\ngithub.deployment.resource.cpu.limit: The CPU limit for the service.\ngithub.deployment.resource.memory.request: The memory request for the service.\ngithub.deployment.resource.memory.limit: The memory limit for the service.\ngithub.deployment.hostnames: The hostnames for the service.\ngithub.deployment.hostnames.host: The hostname for the service.\ngithub.deployment.hostnames.acmARN: The ACM ARN for the service.\ngithub.deployment.hostnames.defaultInternalHostname: The default internal hostname for the service.\ngithub.deployment.hostnames.defaultPublicUrl: The default public URL for the service.","helm-1#helm":"github.deployment.helm: The Helm configuration for the Github service.\ngithub.deployment.helm.enabled: If true, Helm will be used to deploy the service.\ngithub.deployment.helm.chartName: The name of the Helm chart to use for the service.\ngithub.deployment.helm.chartRepoUrl: The URL of the Helm chart repository to use for the service.\ngithub.deployment.helm.chartVersion: The version of the Helm chart to use for the service.\ngithub.deployment.helm.cmdPs: The command to run to get the status of the service.\ngithub.deployment.helm.action: The action to perform on the service.\ngithub.deployment.helm.customValues: A list of custom values to pass to the Helm\ngithub.deployment.helm.customValueFiles: A list of custom value files to pass to the Helm chart.\ngithub.deployment.helm.helmVersion: The version of Helm to use for the service.\ngithub.deployment.helm.attachPvc: The PVC configuration for the service.\ngithub.deployment.helm.attachPvc.enabled: If true, a PVC will be attached to the service.\ngithub.deployment.helm.attachPvc.mountPath: The path to mount the PVC to.","readiness-1#readiness":"github.deployment.readiness: The readiness configuration for the Github service.\ngithub.deployment.readiness.disabled: If true, the service will not be ready.\ngithub.deployment.readiness.tcpSocketPort: The port to use for the TCP socket.\ngithub.deployment.readiness.httpGet: The network configuration for the Github service.\ngithub.deployment.readiness.httpGet.path: The path to use for the HTTP GET request.\ngithub.deployment.readiness.httpGet.port: The port to use for the HTTP GET request.\ngithub.deployment.readiness.initialDelaySeconds: The number of seconds to wait before starting the readiness check.\ngithub.deployment.readiness.periodSeconds: The number of seconds between each readiness check.\ngithub.deployment.readiness.timeoutSeconds: The number of seconds to wait for a readiness check to complete.\ngithub.deployment.readiness.successThreshold: The number of consecutive successful readiness checks before considering the service ready.\ngithub.deployment.readiness.failureThreshold: The number of consecutive failed readiness checks before considering the service not ready.","network-1#network":"github.deployment.network: The network configuration for the Github service.\ngithub.deployment.network.ipWhitelist: A list of IP addresses to whitelist for the service.\ngithub.deployment.network.pathPortMapping: A mapping of paths to ports for the service.\ngithub.deployment.network.hostPortMapping: A mapping of host ports to container ports for the service.\ngithub.deployment.network.grpc: The gRPC configuration for the service.\ngithub.deployment.network.grpc.enable: If true, gRPC will be enabled for the service.\ngithub.deployment.network.grpc.host: The host to use for gRPC.\ngithub.deployment.network.grpc.defaultHost: The default host to use for gRPC.","servicedisks-1#serviceDisks":"github.deployment.serviceDisks: A list of service disks to attach to the Github service.\ngithub.deployment.serviceDisks.name: The name of the service disk.\ngithub.deployment.serviceDisks.mountPath: The path to mount the service disk to.\ngithub.deployment.serviceDisks.accessModes: The access modes for the service disk.\ngithub.deployment.serviceDisks.storageSize: The size of the service disk.\ngithub.deployment.serviceDisks.medium: The medium to use for the service disk."}},"/docs/setup/configure-lifecycle":{"title":"Additional Configuration","data":{"":"We are in the final step of the setup process.This step is Optional but highly recommended to ensure the default IP Whitelist is set for the environments created by the Lifecycle app. This will help in securing the environments and restricting access to only the specified IPs or CIDR blocks.","set-default-ip-whitelist#Set Default IP Whitelist":"Connect to the postgres database using the psql command line tool or any other database client.\nDatabase password was auto generated during the infra setup and can be found\nretrieved from the app-postgres secret in the lifecycle-app\nnamespace.\nRetrieve the database password:\nRun the following SQL commands to update the configuration:\nNote that the infra setup with the OpenTofu modules below will open your\ncluster to the world. \n🛡️ Make sure to shield your cluster by implementing appropriate network policies\nand access controls after the initial setup.Replace the defaultIPWhiteList under global_config.serviceDefaults with your actual IP whitelist or CIDR block to restrict access to the deployed environments.","refresh-config-cache#Refresh config cache":"This will refresh the configuration cache and apply the changes you made to the database for the Lifecycle app.We are all set! 🎉 And ready to create our first PR based ephemeral environment."}},"/docs/setup/create-github-app":{"title":"Configure Application","data":{"":"To create a Github app that will send events to the Lifecycle with necessary permissions, follow these steps:\nMake sure you have admin access to the Github organization or account where\nyou want to create the app.\nNavigate to your installed Lifecycle app at https://app.<your_domain>/setup (replace <your_domain> with your actual domain. e.g. https://app.0env.com/setup).\nSelect Personal or Organization based on your needs.\nFill in the required fields:\nGithub App Name: A name for your app. (should be unique, use a prefix with your name or organization. Refer Github app naming convention here\nOrganization Name: Github organization name where the app will be created. Required if you selected Organization.\nClick Create App\nOn the Github app creation page, confirm the app name and click Create\nOnce the app is created, you will be redirected to the app installation page where you can choose one or more repositories to install the the newly minted app.\nMake sure to select the repositories you want the app to have access to. You\ncan always change this later in the app settings but adding atleast one\nrepository is required to proceed with the setup.\nVoila! 🎉 Your Github app is now created and installed.\nClick Configure and Restart to apply the changes and start using the app.\nThe step above, sets up the global config values that Lifecycle app will use\ncreating ephemeral environments and processing pull requests. And restarts the\ndeployment for the github app secrets to take effect.\nLet's move on the final step where we will configure the Lifecycle app config for processing pull requests and creating ephemeral environments."}},"/docs/setup/install-lifecycle":{"title":"Install Lifecycle","data":{"":"Now that the infrastructure components are setup, let's install the lifecycle app and create a new Github app that will send events to the application to process and create ephemeral dev environments.\nMake sure you have updated the kube config to be able to helm install in the\ncluster you just created!\nClone the repository:\nUpdate the custom values file at /helm/environments/defaults.yaml:\nInstall the Lifecycle Helm chart:\nWait for the installation to complete and verify that the pods are running:\nMake sure to replace values with your actual domain and update the secret name\naccordingly. Secret was created by the opentofu modules in the infrastructure\nsetup (app-<domain>-<tld>).\nOnce the pods are running, you can access the application at your configured domain (e.g. https://app.0env.com)\nJust like that, you have successfully installed Lifecycle and set up the necessary infrastructure to start creating ephemeral environments for your GitHub pull requests!Let's move on to the next step where we will create a GitHub app to connect Lifecycle with your repositories."}},"/docs/setup/prerequisites":{"title":"Prerequisites","data":{"":"Before we start with the setup, let's make sure the following prerequisites are in place:\nGitHub Account: You'll need either a personal or an organization GitHub account. Sign up for GitHub\nCloud Provider Account: A Google Kubernetes Engine (GKE) or Amazon Web Services (AWS) Account. You'll need an active account with either platform to proceed.\nSign up for Google Cloud and create a project\nSign up for AWS\nWe recommend using an isolated project or account in your cloud provider\nspecifically for this setup to begin with. This helps to keep your resources\norganized and manageable as you experiment with Lifecycle.\nCLI Tools\nOpenTofu — Infrastructure as code tool (OpenTofu is a community-driven fork of Terraform).\nkubectl — Command-line tool for interacting with Kubernetes clusters.\ngcloud or aws-cli — Command-line tools for managing Google Cloud or AWS resources, respectively.\nCustom Domain: You will need a custom domain (e.g., 0env.com) to route traffic to your application environments. This is particularly important for setting up:\nPublic callback and webhook URLs for the GitHub App\nIngress routing within the Kubernetes cluster\nSecure (HTTPS) access via TLS certificates\nDNS Provider with Wildcard Support: The domain must be managed by a DNS provider that supports wildcard DNS records (e.g., *.0env.com). This is necessary to dynamically route traffic from GitHub to the Lifecycle app and to ephemeral environments.Supported DNS providers that support wildcard for infrastructure setup include:\nManual Setup:\nSetup a public DNS zone in Google Cloud to manage your domain's DNS records.\nFollow steps here to setup a\npublic DNS zone.\nWildcard DNS records will be created by the OpenTofu modules in the next steps.\nCLI Setup:\nUse the gcloud CLI to create a public DNS zone for your domain:\nUpdate your domain's DNS records with NS records provided by Google Cloud DNS. You can find these in the Google Cloud Console under the DNS zone you created.\nAWS Route 53: Amazon's scalable DNS web\nservice designed to route end users to Internet applications.Manual Setup:\nAuthenticate with AWS CLI using the role/usr you desire.\nEnsure you have your domain provisioned to accept wildcards; eg *.lifecycle.<your-domain>.com\nCLI Setup:\nIf you want to use Cloudflare as your primary DNS provider and manage your DNS records on Cloudflare, your domain should be using a full setup.\nThis means that you are using Cloudflare for your authoritative DNS nameservers.\nFollow the steps here to setup a public DNS zone in Cloudflare.\nEnsure that your domain’s nameservers are pointing to your chosen DNS provider\nat your registrar, and that you have permission to create and manage DNS\nrecords programmatically.  This is crucial for the setup to work\ncorrectly and will take time to propagate.Use https://dnschecker.org/#NS to verify that your domain's nameservers are correctly set up.\nOnce you have these prerequisites in place, you can proceed to the next steps in setting up the cluster and application."}},"/docs/setup/setup-infra":{"title":"Setup your cluster","data":{"":"Based on the prerequisites you've set up, you're now ready to configure your Kubernetes cluster for Lifecycle. This setup will ensure that your cluster is properly configured to run Lifecycle and manage your application environments effectively.\nNote that the infra setup with the OpenTofu modules below will open your\ncluster to the world. \n🛡️ Make sure to shield your cluster by implementing appropriate network policies\nand access controls after the initial setup.\nClick on the cloud provider you are using to set up your cluster:\nGoogle Cloud Platform (GCP)\nAmazon Web Services (AWS)","google-cloud-platform#Google Cloud Platform":"","setup-application-credentials#Setup application credentials":"Enable Kubernetes Engine and Cloud DNS APIs:\nNote that you need to replace <PROJECT_ID> with your actual Google Cloud project ID not the project name.","bootstrap-infrastructure#Bootstrap infrastructure":"Clone the infrastructure repository:\nFollow steps in the infrastructure repository to set up the necessary infrastructure components.\nExample secrets.auto.tfvars file:\nInitialize and apply the Terraform configuration:\nThis will create the necessary infrastructure components, including the Kubernetes cluster, DNS records, database, redis and other resources required for Lifecycle to function properly.After the Terraform apply completes, you should have a fully functional Kubernetes cluster with the necessary resources set up.Let's test the public DNS setup by accessing the test application deployed called kuard and follow the rest of the setup instructions from the tofu apply output.\nRefer example output here to setup kubeconfig and access the cluster using kubectl.Now that your cluster is set up, you can proceed to installing Lifecycle application to your cluster.","amazon-web-services#Amazon Web Services":"*This profile needs to have access a user with AdministratorAccess access.","bootstrap-infrastructure-1#Bootstrap infrastructure":"Clone the infrastructure repository:\nFollow steps in the infrastructure repository to set up the necessary infrastructure components.\nExample secrets.auto.tfvars file:\nInitialize and apply the Terraform configuration:\nThis will create the necessary infrastructure components, including the Kubernetes cluster, DNS records, database, redis and other resources required for Lifecycle to function properly.After the Terraform apply completes, you should have a fully functional Kubernetes cluster with the necessary resources set up.Let's test the public DNS setup by accessing the test application deployed called kuard and follow the rest of the setup instructions from the tofu apply output.\nRefer example output here to setup kubeconfig and access the cluster using kubectl.Now that your cluster is set up, you can proceed to installing Lifecycle application to your cluster."}},"/docs/tips/telemetry":{"title":"Telemetry","data":{"":"Lifecycle comes with built-in support for Datadog telemetry. To collect logs and metrics from your cluster and deployed applications, install the Datadog Agent and Cluster Agent in your cluster.The deployed applications are already configured with the necessary Datadog labels and environment variables for seamless integration:Pod labels:\nEnvironment variables:\nThis setup ensures that Datadog automatically detects the environment, service, and version for each application, enabling rich observability and correlation of logs and metrics in the Datadog platform."}},"/docs/tips/using-mission-control":{"title":"Mission Control comment","data":{"":"Lifecycle uses Mission Control PR Comments to allow users to modify and customize their environments directly from the pull request comment. This enables easy service selection, branch customization, and environment variable overrides without modifying lifecycle.yaml.","selecting-and-deselecting-services#Selecting and Deselecting Services":"Each pull request environment includes default services and optional additional services. You can enable or disable services using the checkboxes.\nEnabled Services are marked with [x].\nDisabled Services are marked with [ ].\nExample:\nTo enable a service, change [ ] to [x]. To disable a service, change [x] to [ ]. As simple as that!\nIf you need to make multiple selections or deselections at once, use the\nEdit Comment option instead of clicking checkboxes individually. This\nprevents multiple back-to-back builds, as each selection triggers an event in\nLifecycle without deduplication.","choosing-a-branch#Choosing a Branch":"To deploy a specific branch for a service, modify the branch name after the service name.Example:\nThis will deploy frontend using the feature-branch instead of the default branch.","overriding-environment-variables#Overriding Environment Variables":"To set additional environment variables, use the Override Environment Variables section in the PR comment.Example:\nThis sets API_URL and CHIEF_INTERN in the environment without modifying the service configuration.","override-uuid#Override UUID":"To set a custom UUID (subdomain) for the environment, use the Override UUID section in the PR comment.\nReplace quiet-breeze-882712 with your desired subdomain. This allows you to customize the environment URL without changing the underlying service configuration.Using the Mission Control PR Comment, you can easily customize your environment without modifying code, making it a flexible way to test and deploy changes dynamically."}},"/docs/troubleshooting/build-issues":{"title":"Troubleshooting Build Issues","data":{"":"TODO: This document will cover common build issues that you may encounter when\nworking with Lifecycle environments."}},"/docs/troubleshooting/deploy-issues":{"title":"Deploy Issues","data":{"":"TODO: This document will cover common deploy issues that you may encounter\nwhen working with Lifecycle environments."}},"/docs/troubleshooting/github-app-webhooks":{"title":"Missing PR comment","data":{"":"Let's quickly validate that the app is able to send events to the Lifecycle app successfully.\nNavigate to your Github app\nClick App Settings link in the Github application page\nChoose Advanced from the left sidebar\nRecent Deliveries section should show a successful delivery of the installation event to the Lifecycle app.\nIf you see an error or no deliveries, make sure the app is installed in the\natleast one repository and that the webhook URL is set correctly by\nnavigating to the General section from the left sidebar and checking the\nWebhook URL field.\nIf the delivery is successful, you should see a status code of 200 OK","failing-deliveries#Failing deliveries":"If you see a delivery failure, it could be due to various reasons. Here are some common issues and how to resolve them:","github-app-secrets#Github App secrets":"Make sure that the Github App secrets are correctly set in the lifecycle-app namespace. You can verify this by running the following command:\nThe output should include all the GITHUB_* variables with the correct values.\nIf the secrets are present but the delivery is still failing, try restarting the following deployments.\nTry triggering a new event (create a pull request) by making a change in the repository or by manually redelivering a failed delivery."}},"/docs/what-is-lifecycle":{"title":"What is Lifecycle?","data":{"":"Lifecycle is an ephemeral (/əˈfem(ə)rəl/, lasting for a very short time) environment orchestrator that transforms your GitHub pull requests into fully functional development environments. It enables developers to test, validate, and collaborate on features without the hassle of managing infrastructure manually.\nWith Lifecycle, every pull request gets its own connected playground—ensuring that changes can be previewed, integrated, and verified before merging into its main branch.","a-developers-story#A Developer’s Story":"Imagine working in an organization that develops multiple services. Managing and testing changes across these services can be challenging, especially when multiple developers are working on different features simultaneously.Meet Nick Holiday 👨‍💻, an engineer who needs to update a database schema and modify the corresponding API in a backend service. Additionally, his change requires frontend service updates to display the new data correctly.","traditional-workflow-challenges#Traditional Workflow Challenges":"Shared environments – Nick deploys his backend service changes to a shared dev or staging environment, but another engineer is testing unrelated changes at the same time.\nConflicting updates – The frontend engineers working on the UI might face issues if their code depends on a stable backend service that keeps changing.\nEnvironment management – Setting up and maintaining an isolated environment for testing requires significant effort.","enter-lifecycle#Enter Lifecycle":"With Lifecycle, as soon as Nick opens a pull request, the system automatically:\n🏗️ Creates an isolated development environment – This environment includes Nick’s updated backend service along with the necessary frontend services.\n🚀 Deploys the application – Everything is set up exactly as it would be in production, ensuring a reliable test scenario.\n🔗 Generates a shareable URL – Nick and his teammates can interact with the new features without setting up anything locally.\n🧹 Cleans up automatically – Once the PR is merged or closed, Lifecycle removes the environment, keeping things tidy.","watch-a-quick-demo#Watch a Quick Demo":"","how-it-works#How It Works":"","why-use-lifecycle#Why Use Lifecycle?":"Faster Feedback Loops - Get instant previews of your changes without waiting for staging deployments.\nIsolation - Each PR runs in its own sandbox, preventing conflicts.\nSeamless Collaboration - Share URLs with stakeholders, designers, or QA engineers.\nAutomatic Cleanup - No more stale test environments; Lifecycle manages cleanup for you.\nWorks with Your Stack - Supports containerized applications and integrates with Kubernetes."}},"/":{"title":"Lifecycle","data":{}},"/tags/app":{"title":"app","data":{}},"/tags/automation":{"title":"automation","data":{}},"/tags/auto":{"title":"auto","data":{}},"/tags/aws":{"title":"aws","data":{}},"/tags/branchname":{"title":"branchname","data":{}},"/tags/build":{"title":"build","data":{}},"/tags/builduuid":{"title":"builduuid","data":{}},"/tags/cleanup":{"title":"cleanup","data":{}},"/tags/close":{"title":"close","data":{}},"/tags/cluster":{"title":"cluster","data":{}},"/tags/codefresh":{"title":"codefresh","data":{}},"/tags/comment":{"title":"comment","data":{}},"/tags/configuration":{"title":"configuration","data":{}},"/tags/configure":{"title":"configure","data":{}},"/tags/core":{"title":"core","data":{}},"/tags/datadog":{"title":"datadog","data":{}},"/tags/defaultservices":{"title":"defaultservices","data":{}},"/tags/delete":{"title":"delete","data":{}},"/tags/deploy":{"title":"deploy","data":{}},"/tags/dev-0":{"title":"dev-0","data":{}},"/tags/deployment":{"title":"deployment","data":{}},"/tags/edit":{"title":"edit","data":{}},"/tags/environment":{"title":"environment","data":{}},"/tags/ephemeral-env":{"title":"ephemeral-env","data":{}},"/tags/error":{"title":"error","data":{}},"/tags/explore":{"title":"explore","data":{}},"/tags/first environment":{"title":"first environment","data":{}},"/tags/getting-started":{"title":"getting-started","data":{}},"/tags/github":{"title":"github","data":{}},"/tags/glossary":{"title":"glossary","data":{}},"/tags/gke":{"title":"gke","data":{}},"/tags/internalhostname":{"title":"internalhostname","data":{}},"/tags/intro":{"title":"intro","data":{}},"/tags/issue":{"title":"issue","data":{}},"/tags/install":{"title":"install","data":{}},"/tags/issues":{"title":"issues","data":{}},"/tags/labels":{"title":"labels","data":{}},"/tags/lifecycle-deploy":{"title":"lifecycle-deploy","data":{}},"/tags/lifecycle-disabled":{"title":"lifecycle-disabled","data":{}},"/tags/lifecycle":{"title":"lifecycle","data":{}},"/tags/logs":{"title":"logs","data":{}},"/tags/metrics":{"title":"metrics","data":{}},"/tags/missing":{"title":"missing","data":{}},"/tags/observability":{"title":"observability","data":{}},"/tags/mission control":{"title":"mission control","data":{}},"/tags/onboard":{"title":"onboard","data":{}},"/tags/optionalservices":{"title":"optionalservices","data":{}},"/tags/pr":{"title":"pr","data":{}},"/tags/prerequisites":{"title":"prerequisites","data":{}},"/tags/publicurl":{"title":"publicurl","data":{}},"/tags/pull request":{"title":"pull request","data":{}},"/tags/requirements":{"title":"requirements","data":{}},"/tags/review":{"title":"review","data":{}},"/tags/schema":{"title":"schema","data":{}},"/tags/service-dependencies":{"title":"service-dependencies","data":{}},"/tags/service":{"title":"service","data":{}},"/tags/setup":{"title":"setup","data":{}},"/tags/sha":{"title":"sha","data":{}},"/tags/start":{"title":"start","data":{}},"/tags/static":{"title":"static","data":{}},"/tags/tear down":{"title":"tear down","data":{}},"/tags/telemetry":{"title":"telemetry","data":{}},"/tags/template":{"title":"template","data":{}},"/tags/term":{"title":"term","data":{}},"/tags/terminology":{"title":"terminology","data":{}},"/tags/todo":{"title":"todo","data":{}},"/tags/uuid":{"title":"uuid","data":{}},"/tags/tutorial":{"title":"tutorial","data":{}},"/tags/variables":{"title":"variables","data":{}},"/tags/webhook":{"title":"webhook","data":{}}}
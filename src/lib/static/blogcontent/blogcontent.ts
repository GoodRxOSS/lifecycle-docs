export const blogContent = [
  {
    title: "Introducing Lifecycle",
    description: null,
    date: "2025-06-05",
    path: "articles/introduction",
    body: '## Quick Reference\n\n| Attribute | Details |\n|-----------|---------|\n| **What** | On-demand ephemeral environments from GitHub PRs |\n| **Origin** | Built at GoodRx starting 2019 |\n| **License** | Apache 2.0 (open source) |\n| **Configuration** | Single `lifecycle.yaml` per repository |\n| **Community** | [Discord](https://discord.gg/M5fhHJuEX8) |\n\n## The Problem We Faced\n\nIn 2019, GoodRx\'s shift from monolith to microservices created environment chaos:\n\n D1[Deploys to staging] --> Q1["Is anyone using staging?"]\n    B[Developer B] --> D2[Overwrites A\'s code] --> Q2["Who broke staging?"]\n    C[Developer C] --> D3[Waits hours/days] --> Q3[Productivity lost]\n`} />\n\nShared staging environments meant constant conflicts, broken deployments, and wasted time.\n\n## The Solution\n\nWe built **Lifecycle**: a tool that creates isolated, ephemeral environments for every GitHub pull request.\n\n**Before Lifecycle:**\n- Static staging servers with deployment conflicts\n- Manual coordination via Slack: "Is staging free?"\n- Hours or days waiting to test changes\n\n**After Lifecycle:**\n- Every PR gets its own isolated environment\n- No coordination needed\n- Instant feedback on code changes\n\n## Our Journey\n\n\n\nKey milestones:\n1. **Proof of concept** - Handful of services onboarded\n2. **Organic growth** - Engineers requested Lifecycle for all projects\n3. **Standardization** - Created `lifecycle.yaml` config, replaced manual database entries\n4. **Maturity** - Became essential infrastructure at GoodRx\n\n## Why We Open-Sourced\n\nThis release represents five years of development, countless iterations, and hard-won lessons. We open-sourced Lifecycle to:\n\n- Help teams escape "environment limbo"\n- Build a community of contributors\n- See novel use cases we never imagined\n\n## Get Involved\n\nWe want to learn from you and grow together.\n\n| Action | Link |\n|--------|------|\n| Join the community | [Discord](https://discord.gg/M5fhHJuEX8) |\n| Explore the docs | [What is Lifecycle?](/docs/what-is-lifecycle) |\n| Get started | [Setup Guide](/docs/setup) |',
  },
  {
    title: "What is Lifecycle?",
    description:
      "Lifecycle is your effortless way to test and create ephemeral environments",
    date: "2025-03-12",
    path: "docs/what-is-lifecycle",
    body: "# What is Lifecycle?\n\nLifecycle automatically creates isolated, fully-functional environments for every GitHub pull request. No manual setup, no environment conflicts, no cleanup headaches.\n\n## Quick Reference\n\n| What | Description |\n|------|-------------|\n| **Purpose** | Ephemeral environment orchestrator for PR-based development |\n| **Trigger** | Opens a PR on GitHub |\n| **Result** | Isolated Kubernetes namespace with your services deployed |\n| **Configuration** | Single `lifecycle.yaml` file in your repository |\n| **Cleanup** | Automatic when PR is merged or closed |\n\n## How It Works\n\n B[Lifecycle reads config]\n    B --> C[Builds services]\n    C --> D[Deploys to isolated namespace]\n    D --> E[Shareable URL ready]\n    E --> F[User validates]\n    F --> G[Environment torn down]\n    G --> H[PR Merged]\n`} />\n\n\n\n**The workflow in detail:**\n\n1. Developer opens a PR on GitHub\n2. Webhook triggers Lifecycle to read `lifecycle.yaml`\n3. Services are built and deployed to a dedicated Kubernetes namespace\n4. Shareable URLs are generated and posted to the PR\n5. Environment auto-deletes when PR closes\n\n## Key Capabilities\n\n### Deployment Types\n\n| Type | Use Case |\n|------|----------|\n| `GITHUB` | Build and deploy from source code |\n| `DOCKER` | Deploy pre-built Docker images |\n| `HELM` | Deploy using Helm charts |\n| `EXTERNAL_HTTP` | Reference external services |\n| `AURORA_RESTORE` | Clone Aurora databases for testing |\n\n### Built-in Features\n\n- **Multi-service orchestration** - Deploy interconnected services with automatic dependency handling\n- **Multi-repo support** - Include services from different repositories in one environment\n- **Native builds** - Kubernetes-native building with BuildKit or Kaniko\n- **Real-time logs** - Stream build and deployment logs via web UI or API\n- **TTL-based cleanup** - Configurable expiration prevents resource waste\n- **SPOT instance support** - Minimize infrastructure costs\n\n## Use Cases\n\n| Scenario | Benefit |\n|----------|---------|\n| **Feature development** | Isolated environments prevent conflicts between developers |\n| **QA testing** | Fully connected environments for manual and automated tests |\n| **Design review** | Live URLs for product managers and designers to interact with |\n| **Partner sandboxes** | Isolated environments sharing only what's necessary |\n\n## Why Lifecycle?\n\n**Without Lifecycle:**\n- Shared dev/staging environments with constant conflicts\n- Manual environment setup eating into development time\n- Stale test environments consuming resources\n- Slow feedback loops waiting for staging deployments\n\n**With Lifecycle:**\n- Every PR gets its own isolated sandbox\n- Zero setup - just open a PR\n- Automatic cleanup when done\n- Instant previews with shareable URLs\n\n## Quick Demo\n\n\n\n## Next Steps\n\nReady to get started? See the [Setup Guide](/docs/setup) to install Lifecycle in your cluster.",
  },
  {
    title: "Diagram Comparison",
    description: "Comparing Mermaid vs Excalidraw for documentation diagrams",
    date: "2025-01-17",
    path: "docs/diagram-comparison",
    body: "# Diagram Comparison: Mermaid vs Excalidraw\n\nThis page compares the two diagram options for documentation.\n\n## Simple Flow Diagram\n\n### Mermaid Version\n\n B[Lifecycle reads config]\n    B --> C[Builds services]\n    C --> D[Deploys to namespace]\n    D --> E[URL ready]\n`} />\n\n### Excalidraw Version\n\n\n\n---\n\n## Comparison Summary\n\n| Aspect | Mermaid | Excalidraw |\n|--------|---------|------------|\n| **Syntax** | Text-based DSL | JSON element array |\n| **Lines of code** | ~5 lines | ~50+ lines |\n| **Ease of editing** | Easy (just text) | Hard (need coordinates) |\n| **Visual style** | Clean/professional | Hand-drawn/sketch |\n\n## Recommendation\n\n**Mermaid is recommended** for documentation.",
  },
  {
    title: "Auto Deploy & Labels",
    description:
      "How automatic deployments work and how to control environments with labels",
    date: "2025-01-29",
    path: "docs/features/auto-deployment",
    body: '## Quick Reference\n\n| Label | Effect | Use When |\n|-------|--------|----------|\n| `lifecycle-deploy!` | Deploy environment, rebuild on push | You want to test changes |\n| `lifecycle-disabled!` | Tear down, block all deploys | Temporarily pause testing |\n| `lifecycle-keep!` | Prevent automatic cleanup | Long-running test environment |\n| `lifecycle-status-comments!` | Post status updates to PR | You want build progress in PR |\n\n**TL;DR:** Set `autoDeploy: true` to deploy on every PR. Use labels for manual control.\n\n---\n\n## Label Precedence\n\n B{lifecycle-disabled! present?}\n    B -->|YES| C[Environment DISABLEDhighest priority]\n    B -->|NO| D{lifecycle-deploy! present?}\n    D -->|YES| E[Environment ENABLED]\n    D -->|NO| F{autoDeploy: truein lifecycle.yaml?}\n    F -->|YES| G[Environment ENABLED]\n    F -->|NO| H[Environment DISABLED]\n`} />\n\n\n`lifecycle-disabled!` always wins. If both deploy and disabled labels are present, the environment stays disabled.\n\n\n---\n\n## Configuration\n\nEnable automatic deployment when PRs are opened:\n\n```yaml filename="lifecycle.yaml"\nenvironment:\n  autoDeploy: true\n  defaultServices:\n    # your services...\n```\n\n| Setting | Behavior |\n|---------|----------|\n| `autoDeploy: true` | Deploy automatically when PR opens, add `lifecycle-deploy!` label |\n| `autoDeploy: false` (default) | Wait for manual `lifecycle-deploy!` label |\n\n---\n\n## Common Patterns\n\n### Pattern 1: Always Deploy (Active Development)\n\nBest for teams that want every PR to have an environment.\n\n```yaml filename="lifecycle.yaml"\nenvironment:\n  autoDeploy: true\n```\n\n**Flow:** PR opened → Environment deploys → Pushes rebuild automatically\n\n### Pattern 2: On-Demand Deploy (Selective Testing)\n\nBest for high-volume repos where you only test specific PRs.\n\n```yaml filename="lifecycle.yaml"\nenvironment:\n  autoDeploy: false\n```\n\n**Flow:** PR opened → Nothing happens → Add `lifecycle-deploy!` → Environment deploys\n\n### Pattern 3: Long-Running Test Environment\n\nFor environments that need to persist beyond normal TTL cleanup.\n\n1. Add `lifecycle-deploy!` to deploy\n2. Add `lifecycle-keep!` to prevent automatic cleanup\n3. Environment persists until PR closes or you remove labels\n\n---\n\n## WRONG vs CORRECT Examples\n\n### Expecting deployment without configuration\n\n```yaml filename="lifecycle.yaml"\n# WRONG: Missing autoDeploy, nothing deploys automatically\nenvironment:\n  defaultServices:\n    - name: api\n```\n\n```yaml filename="lifecycle.yaml"\n# CORRECT: Explicitly enable auto-deploy\nenvironment:\n  autoDeploy: true\n  defaultServices:\n    - name: api\n```\n\n### Trying to deploy with disabled label present\n\n```\n# WRONG: Both labels present - disabled wins, no deployment\nLabels: lifecycle-deploy!, lifecycle-disabled!\nResult: Environment torn down\n```\n\n```\n# CORRECT: Remove disabled label first\nLabels: lifecycle-deploy!\nResult: Environment deploys\n```\n\n### Config in wrong branch\n\n```\n# WRONG: lifecycle.yaml only in main branch\nPR branch: feature/new-api (no lifecycle.yaml)\nResult: Lifecycle cannot read config, deployment fails\n```\n\n```\n# CORRECT: lifecycle.yaml in PR branch\nPR branch: feature/new-api (has lifecycle.yaml)\nResult: Lifecycle reads config from PR, deployment succeeds\n```\n\n---\n\n## PR Event Behavior\n\n| Event | Deploy Enabled | Deploy Disabled |\n|-------|----------------|-----------------|\n| PR opened | Build & deploy | Create records only |\n| PR reopened | Build & deploy | Create records only |\n| Push commits | Rebuild affected services | No action |\n| PR closed/merged | Tear down environment | Tear down environment |\n\n### Label Changes\n\n| Action | Result |\n|--------|--------|\n| Add `lifecycle-deploy!` | Set `deployOnUpdate=true`, trigger build |\n| Remove `lifecycle-deploy!` | Set `deployOnUpdate=false`, tear down |\n| Add `lifecycle-disabled!` | Set `deployOnUpdate=false`, tear down, block future deploys |\n| Remove `lifecycle-disabled!` | Restore previous deploy state |\n\n---\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| PR opened but no deployment | Verify `autoDeploy: true` in `lifecycle.yaml` on PR branch, or add `lifecycle-deploy!` manually |\n| Environment torn down unexpectedly | Check for `lifecycle-disabled!` label; verify PR is still open |\n| Pushes not triggering rebuilds | Ensure `lifecycle-deploy!` label present and `lifecycle-disabled!` absent |\n| Can\'t deploy even with deploy label | Remove `lifecycle-disabled!` label (it takes precedence) |\n\n---\n\n## Quick Decision Guide\n\n| I want to... | Do this |\n|--------------|---------|\n| Deploy every PR automatically | Set `autoDeploy: true` |\n| Deploy only specific PRs | Keep `autoDeploy: false`, add `lifecycle-deploy!` when needed |\n| Stop deploying a PR | Remove `lifecycle-deploy!` or add `lifecycle-disabled!` |\n| Prevent accidental redeployment | Add `lifecycle-disabled!` (blocks deploy label too) |\n| Keep environment alive longer | Add `lifecycle-keep!` |\n| See build status in PR | Add `lifecycle-status-comments!` |\n| Tear down an environment | Close PR, remove `lifecycle-deploy!`, or add `lifecycle-disabled!` |',
  },
  {
    title: "Webhooks",
    description: "Trigger automated tasks when build states change",
    date: "2025-01-29",
    path: "docs/features/webhooks",
    body: '# Webhooks\n\nAutomate external processes when your build state changes—run tests, send notifications, or perform cleanup tasks.\n\n## Quick Reference\n\n| Type | Best For | Key Config |\n|------|----------|------------|\n| `codefresh` | Existing CI/CD pipelines | `pipelineId`, `trigger` |\n| `docker` | Custom containers, full control | `docker.image`, `docker.command` |\n| `command` | Quick scripts, notifications | `command.image`, `command.script` |\n\n**Trigger States:** `deployed` | `error` | `torn_down`\n\n\nWebhook failures do **not** affect your build status—failures are recorded but deployments continue.\n\n\n---\n\n## How It Works\n\n(deployed / error / torn_down)"]\n    B["Lifecycle checks for webhooksmatching that state"]\n    C["Webhooks execute serially in order"]\n    D["Results recorded(view at /builds/[uuid]/webhooks)"]\n\n    A --> B\n    B --> C\n    C --> D\n`} />\n\n---\n\n## Configuration by Type\n\n### Codefresh Webhook\n\nTrigger existing Codefresh CI/CD pipelines.\n\n```yaml\nenvironment:\n  webhooks:\n    - name: "E2E Tests"\n      state: deployed\n      type: codefresh\n      pipelineId: 64598362453cc650c0c9cd4d\n      trigger: tests\n      env:\n        branch: "{{frontend_branchName}}"\n        TEST_URL: "https://{{frontend_publicUrl}}"\n```\n\n| Field | Required | Description |\n|-------|----------|-------------|\n| `pipelineId` | Yes | Codefresh pipeline ID |\n| `trigger` | Yes | Codefresh trigger name |\n\n### Docker Webhook\n\nExecute a Docker image as a Kubernetes job—best for custom containers.\n\n```yaml\nenvironment:\n  webhooks:\n    - name: "E2E Test Suite"\n      state: deployed\n      type: docker\n      docker:\n        image: "myorg/e2e-tests:latest"\n        command: ["npm", "run", "e2e"]\n        args: ["--headless", "--ci"]\n        timeout: 3600\n      env:\n        BASE_URL: "https://{{frontend_publicUrl}}"\n```\n\n| Field | Required | Default | Description |\n|-------|----------|---------|-------------|\n| `docker.image` | Yes | — | Docker image to execute |\n| `docker.command` | No | — | Override container entrypoint |\n| `docker.args` | No | — | Arguments for the command |\n| `docker.timeout` | No | 1800s | Max execution time |\n\n### Command Webhook\n\nRun a shell script in a container—ideal for quick tasks.\n\n```yaml\nenvironment:\n  webhooks:\n    - name: "Slack Notification"\n      state: deployed\n      type: command\n      command:\n        image: "curlimages/curl:latest"\n        script: |\n          curl -X POST "$SLACK_WEBHOOK" \\\n            -H "Content-Type: application/json" \\\n            -d "{\\"text\\":\\"Deployed $SERVICE to $URL\\"}"\n        timeout: 60\n      env:\n        SLACK_WEBHOOK: "https://hooks.slack.com/services/XXX"\n        SERVICE: "{{frontend_internalHostname}}"\n        URL: "https://{{frontend_publicUrl}}"\n```\n\n| Field | Required | Default | Description |\n|-------|----------|---------|-------------|\n| `command.image` | Yes | — | Docker image for script execution |\n| `command.script` | Yes | — | Shell script to execute |\n| `command.timeout` | No | 1800s | Max execution time |\n\n---\n\n## Common Fields (All Types)\n\n| Field | Required | Description |\n|-------|----------|-------------|\n| `name` | No | Human-readable identifier |\n| `description` | No | What the webhook does |\n| `state` | Yes | `deployed`, `error`, or `torn_down` |\n| `type` | Yes | `codefresh`, `docker`, or `command` |\n| `env` | Yes | Environment variables (can be `{}`) |\n\n---\n\n## Template Variables\n\nInject build-specific values using `{{variable}}` syntax:\n\n| Variable | Example Output |\n|----------|----------------|\n| `{{serviceName_publicUrl}}` | `my-service-abc123.example.com` |\n| `{{serviceName_branchName}}` | `feature/my-branch` |\n| `{{serviceName_internalHostname}}` | `my-service.namespace.svc` |\n| `{{serviceName_dockerImage}}` | `myorg/service:sha-abc123` |\n| `{{serviceName_sha}}` | `abc123def456` |\n| `{{buildUUID}}` | `550e8400-e29b-41d4-a716-446655440000` |\n| `{{namespace}}` | `lifecycle-pr-123` |\n| `{{pullRequestNumber}}` | `123` |\n\nReplace `serviceName` with your actual service name from the Lifecycle config.\n\n---\n\n## Common Mistakes\n\n### Wrong: Missing env field\n\n```yaml\n# WRONG - env field is required even if empty\nenvironment:\n  webhooks:\n    - name: "Test"\n      state: deployed\n      type: docker\n      docker:\n        image: "myorg/tests:latest"\n```\n\n```yaml\n# CORRECT - include env: {} if no variables needed\nenvironment:\n  webhooks:\n    - name: "Test"\n      state: deployed\n      type: docker\n      docker:\n        image: "myorg/tests:latest"\n      env: {}\n```\n\n### Wrong: Template variable typo\n\n```yaml\n# WRONG - service name doesn\'t match config\nenv:\n  URL: "https://{{frontEnd_publicUrl}}"  # Wrong: "frontEnd" vs "frontend"\n```\n\n```yaml\n# CORRECT - use exact service name from your lifecycle.yaml\nenv:\n  URL: "https://{{frontend_publicUrl}}"\n```\n\n### Wrong: No timeout for long-running jobs\n\n```yaml\n# WRONG - E2E tests may exceed 30-minute default\ndocker:\n  image: "mcr.microsoft.com/playwright:latest"\n  command: ["npx", "playwright", "test"]\n```\n\n```yaml\n# CORRECT - set appropriate timeout\ndocker:\n  image: "mcr.microsoft.com/playwright:latest"\n  command: ["npx", "playwright", "test"]\n  timeout: 3600  # 1 hour for comprehensive E2E suite\n```\n\n---\n\n## Practical Patterns\n\n### E2E Tests After Deployment\n\n```yaml\nenvironment:\n  webhooks:\n    - name: "Playwright E2E Tests"\n      state: deployed\n      type: docker\n      docker:\n        image: "mcr.microsoft.com/playwright:v1.40.0"\n        command: ["npx", "playwright", "test"]\n        timeout: 1800\n      env:\n        BASE_URL: "https://{{frontend_publicUrl}}"\n        CI: "true"\n```\n\n### Slack + Discord Notifications\n\n```yaml\nenvironment:\n  webhooks:\n    - name: "Slack Deploy Alert"\n      state: deployed\n      type: command\n      command:\n        image: "curlimages/curl:8.5.0"\n        script: |\n          curl -X POST "$SLACK_WEBHOOK" \\\n            -H "Content-Type: application/json" \\\n            -d \'{"text":"Deployed: \'"$URL"\'"}\'\n        timeout: 30\n      env:\n        SLACK_WEBHOOK: "https://hooks.slack.com/services/XXX"\n        URL: "https://{{frontend_publicUrl}}"\n\n    - name: "Discord Error Alert"\n      state: error\n      type: command\n      command:\n        image: "curlimages/curl:8.5.0"\n        script: |\n          curl -X POST "$DISCORD_WEBHOOK" \\\n            -H "Content-Type: application/json" \\\n            -d \'{"content":"Build failed for PR #\'"$PR"\'"}\'\n        timeout: 30\n      env:\n        DISCORD_WEBHOOK: "https://discord.com/api/webhooks/XXX"\n        PR: "{{pullRequestNumber}}"\n```\n\n### Database Migrations\n\n```yaml\nenvironment:\n  webhooks:\n    - name: "Run Migrations"\n      state: deployed\n      type: docker\n      docker:\n        image: "myorg/db-migrator:latest"\n        command: ["./migrate.sh", "up"]\n        timeout: 600\n      env:\n        DATABASE_URL: "postgres://{{db_internalHostname}}:5432/app"\n```\n\n### Cleanup on Teardown\n\n```yaml\nenvironment:\n  webhooks:\n    - name: "Cleanup External Resources"\n      state: torn_down\n      type: docker\n      docker:\n        image: "myorg/cleanup-tool:latest"\n        timeout: 300\n      env:\n        BUILD_UUID: "{{buildUUID}}"\n```\n\n---\n\n## Resource Limits\n\n| Resource | Request | Limit |\n|----------|---------|-------|\n| CPU | 200m | 200m |\n| Memory | 1Gi | 1Gi |\n\n| Timeout | Default | Maximum |\n|---------|---------|---------|\n| Docker/Command | 30 min | 24 hours |\n| Codefresh | Managed by Codefresh | N/A |\n\n---\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| Webhook not triggering | Verify `state` matches the build state (check spelling) |\n| Template variable empty | Confirm service name matches exactly in your `lifecycle.yaml` |\n| Timeout exceeded | Increase `timeout` value; check if job is stuck |\n| Image pull error | Verify image exists and is accessible from cluster |\n| Script syntax error | Test script locally before deploying |\n| Webhook failed but build succeeded | Expected—webhook failures don\'t affect builds |\n\nView webhook history at `/builds/[uuid]/webhooks` to debug failures.\n\n---\n\n## Summary: When to Use Each Type\n\n| Use Case | Recommended Type | Why |\n|----------|------------------|-----|\n| Run existing CI/CD pipeline | `codefresh` | Native integration, managed timeouts |\n| Custom test suite | `docker` | Full control over image and commands |\n| Send notifications | `command` | Quick, lightweight scripts |\n| Database migrations | `docker` | Reliable execution with custom tools |\n| Cleanup external resources | `docker` | Access to custom tooling |\n| Health checks | `command` | Simple curl/wget scripts |',
  },
  {
    title: "Native Helm Deployment",
    description:
      "Deploy services using Helm directly in Kubernetes without external CI/CD dependencies",
    date: "2025-01-29",
    path: "docs/features/native-helm-deployment",
    body: 'This feature is in active development. Review the changelog for breaking changes before upgrading.\n\n\n## Quick Reference\n\n| Aspect | Details |\n|--------|---------|\n| **What it does** | Runs Helm deployments as Kubernetes jobs (no external CI/CD needed) |\n| **Enable globally** | `helm.nativeHelm.enabled: true` in lifecycle.yaml |\n| **Enable per-service** | `helm.deploymentMethod: "native"` |\n| **Chart types** | ORG_CHART, LOCAL (`./`), PUBLIC (external registries) |\n| **Job timeout** | 30 minutes (configurable) |\n| **Template syntax** | `{{{variable}}}` (triple braces) |\n\n## Quickstart\n\n```yaml filename="lifecycle.yaml"\nservices:\n  - name: my-api\n    helm:\n      deploymentMethod: "native"\n      chart:\n        name: "local"\n        valueFiles:\n          - "./helm/values.yaml"\n```\n\nThis creates a Kubernetes job that runs `helm upgrade --install` for your service.\n\n## How It Works\n\n B[2. Service Account / RBAC Setup]\n        B --> C[3. Init Container / Git Clone]\n    end\n    subgraph Deployment\n        C --> D[4. helm-deploy Container]\n        D --> E[helm upgrade --install]\n    end\n    subgraph Monitoring\n        D --> F[5. WebSocket Streaming]\n        F --> G[Monitor Logs]\n    end\n`} />\n\n## Configuration\n\n### Enable Native Helm\n\n**Per-service:**\n```yaml filename="lifecycle.yaml"\nservices:\n  - name: my-service\n    helm:\n      deploymentMethod: "native"\n      chart:\n        name: my-chart\n```\n\n**Global (all services):**\n```yaml filename="lifecycle.yaml"\nhelm:\n  nativeHelm:\n    enabled: true\n```\n\n\n  Service-level `deploymentMethod` overrides global settings. Use `deploymentMethod: "ci"` to force CI/CD for specific services.\n\n\n### Configuration Precedence\n\n(database)Lowest Priority"] --> B["Chart-specific config(database)"]\n    B --> C["Service YAML(lifecycle.yaml)Highest Priority"]\n`} />\n\n### Chart Types\n\n| Type | Detection | Use Case |\n|------|-----------|----------|\n| **ORG_CHART** | Matches `orgChartName` + has `helm.docker` | Internal organization charts |\n| **LOCAL** | Name is `"local"` or starts with `./` or `../` | Charts in your repo |\n| **PUBLIC** | Everything else | External charts (Bitnami, etc.) |\n\n**PUBLIC charts** skip git clone and build phases unless `valueFiles` reference repo files.\n\n## Common Patterns\n\n### Deploy a Public Chart (Jenkins)\n\n```yaml filename="lifecycle.yaml"\nservices:\n  - name: "jenkins"\n    helm:\n      chart:\n        name: "jenkins"\n        repoUrl: "https://charts.bitnami.com/bitnami"\n        version: "13.6.8"\n        values:\n          - "service.type=ClusterIP"\n          - "ingress.enabled=true"\n          - "ingress.hostname={{{jenkins_publicUrl}}}"\n```\n\nNo repository or branch needed for public charts.\n\n### Local Chart with Custom Values\n\n```yaml filename="lifecycle.yaml"\nservices:\n  - name: web-api\n    helm:\n      deploymentMethod: "native"\n      repository: "myorg/apps"\n      branchName: "main"\n      chart:\n        name: "./charts/app"\n        values:\n          - "image.tag={{{web-api_dockerTag}}}"\n        valueFiles:\n          - "deploy/helm/values.yaml"\n      docker:\n        app:\n          dockerfilePath: "Dockerfile"\n```\n\n### Public Chart with Repo Value Files\n\n```yaml filename="lifecycle.yaml"\nservices:\n  - name: "postgres-db"\n    helm:\n      repository: "myorg/my-repo"\n      branchName: "main"\n      chart:\n        name: "postgresql"\n        repoUrl: "https://charts.bitnami.com/bitnami"\n        version: "12.9.0"\n        valueFiles:\n          - "deploy/helm/db-values.yaml"\n```\n\n## Template Variables\n\nUse `{{{variable}}}` syntax (triple braces). Lifecycle resolves these before passing to Helm.\n\n| Variable | Example Value |\n|----------|---------------|\n| `{{{serviceName_dockerTag}}}` | `main-abc123` |\n| `{{{serviceName_dockerImage}}}` | `registry.com/org/repo:main-abc123` |\n| `{{{serviceName_internalHostname}}}` | `api-service.env-uuid.svc.cluster.local` |\n| `{{{build.uuid}}}` | `env-12345` |\n| `{{{build.namespace}}}` | `env-12345` |\n\n**Example:**\n```yaml\nvalues:\n  - "image.tag={{{web-api_dockerTag}}}"\n  - "backend.url=http://{{{backend-service_internalHostname}}}:8080"\n```\n\n## Environment Variable Mapping\n\nDifferent charts expect env vars in different formats. Use `envMapping` to adapt.\n\n### WRONG vs CORRECT Placement\n\n```yaml\n# WRONG - envMapping under chart\nhelm:\n  chart:\n    name: local\n    envMapping:      # This will NOT work\n      app:\n        format: "array"\n```\n\n```yaml\n# CORRECT - envMapping under helm\nhelm:\n  chart:\n    name: local\n  envMapping:        # Correct placement\n    app:\n      format: "array"\n      path: "env"\n  docker:            # Required for envMapping\n    app:\n      env:\n        MY_VAR: "value"\n```\n\n### Array Format\n\nFor charts expecting Kubernetes-style env arrays:\n\n```yaml filename="lifecycle.yaml"\nhelm:\n  envMapping:\n    app:\n      format: "array"\n      path: "env"\n  docker:\n    app:\n      env:\n        DATABASE_URL: "postgres://localhost:5432/mydb"\n        API_KEY: "secret"\n```\n\n**Produces:**\n```bash\n--set env[0].name=DATABASE_URL --set env[0].value=postgres://localhost:5432/mydb\n--set env[1].name=API_KEY --set env[1].value=secret\n```\n\n### Map Format\n\nFor charts expecting key-value objects:\n\n```yaml filename="lifecycle.yaml"\nhelm:\n  envMapping:\n    app:\n      format: "map"\n      path: "envVars"\n  docker:\n    app:\n      env:\n        DATABASE_URL: "postgres://localhost:5432/mydb"\n```\n\n**Produces:**\n```bash\n--set envVars.DATABASE__URL="postgres://localhost:5432/mydb"\n```\n\n\n  Underscores become double underscores (`__`) in map format to avoid Helm parsing issues.\n\n\n## Global Configuration (Database)\n\nStore defaults in the `global_config` table.\n\n### helmDefaults\n\n```json\n{\n  "version": "3.12.0",\n  "nativeHelm": {\n    "enabled": true,\n    "defaultArgs": "--wait --timeout 30m"\n  }\n}\n```\n\n### Chart-specific (e.g., key: "postgresql")\n\n```json\n{\n  "version": "3.13.0",\n  "args": "--force --timeout 60m0s --wait",\n  "chart": {\n    "name": "postgresql",\n    "repoUrl": "https://charts.bitnami.com/bitnami",\n    "version": "12.9.0"\n  }\n}\n```\n\n## Monitoring Deployments\n\n1. Add `lifecycle-status-comments!` label to your PR\n2. Click **Deploy Logs** in the status comment\n3. View real-time logs via WebSocket\n\nThe log viewer shows:\n- `clone-repo` container (git operations)\n- `helm-deploy` container (Helm execution)\n- Status indicators (Active, Complete, Failed)\n\n## Troubleshooting\n\n### "Another Operation in Progress"\n\n**Problem:** Helm reports an existing operation is blocking.\n\n**Solution:** Native Helm auto-handles this. If it persists:\n```bash\nkubectl get jobs -n env-{uuid} -l service={serviceName}\nkubectl delete job {jobName} -n env-{uuid} --force --grace-period=0\nhelm uninstall {releaseName} -n env-{uuid} --no-hooks\n```\n\n### Environment Variables Not Working\n\n**Problem:** Env vars not passed to deployment.\n\n**Checklist:**\n- [ ] `envMapping` is under `helm:`, not under `chart:`\n- [ ] `docker:` section exists with `env:` defined\n- [ ] `path` matches your chart\'s expected structure\n\n### "Helm Version is Required" Error\n\n**Problem:** Missing version in database config.\n\n**Solution:** Add `version` at top level of `helmDefaults`:\n```json\n{\n  "version": "3.12.0",\n  "nativeHelm": { "enabled": true }\n}\n```\n\n### RBAC Permission Issues\n\n**Problem:** Helm deployment fails with permission errors.\n\n**Solution:**\n```bash\nkubectl get roles,rolebindings -n env-{uuid}\nkubectl describe role native-helm-role -n env-{uuid}\n```\n\n## Migration from GitHub-type to Helm-type\n\n| Before (GitHub-type) | After (Helm-type) |\n|---------------------|-------------------|\n| `github.repository` | `helm.repository` |\n| `github.branchName` | `helm.branchName` |\n| `github.docker` | `helm.docker` |\n| `github.deployment` | `helm.chart.values` |\n| `{{var}}` | `{{{var}}}` |\n\n**Before:**\n```yaml\nservices:\n  - name: "api"\n    github:\n      repository: "myorg/api"\n      docker:\n        app:\n          env:\n            URL: "{{backend_internalHostname}}"\n```\n\n**After:**\n```yaml\nservices:\n  - name: "api"\n    helm:\n      deploymentMethod: "native"\n      repository: "myorg/api"\n      chart:\n        name: "./charts/app"\n        values:\n          - "image.tag={{{api_dockerTag}}}"\n      docker:\n        app:\n          env:\n            URL: "{{{backend_internalHostname}}}"\n```\n\n## Advanced Configuration\n\n### OCI Registry Charts\n\n```yaml\nchart:\n  name: "myapp"\n  repoUrl: "oci://ghcr.io/myorg/charts/myapp"\n  version: "1.2.3"\n```\n\n### Built-in Repository Aliases\n\n| Alias | URL |\n|-------|-----|\n| `bitnami` | `https://charts.bitnami.com/bitnami` |\n| `stable` | `https://charts.helm.sh/stable` |\n| `prometheus-community` | `https://prometheus-community.github.io/helm-charts` |\n| `grafana` | `https://grafana.github.io/helm-charts` |\n\n### Concurrent Deployment Handling\n\nNative Helm uses "newest wins" strategy:\n1. Detects existing jobs with same release name\n2. Annotates as `superseded-by-retry`\n3. Force-deletes existing pods/jobs\n4. Deploys new version\n\n### Job Lifecycle\n\n| Environment | Job TTL |\n|-------------|---------|\n| Ephemeral | Cleaned with namespace |\n| Static | 24 hours after completion |\n\n## Summary\n\n| Task | Configuration |\n|------|---------------|\n| Enable globally | `helm.nativeHelm.enabled: true` |\n| Enable per-service | `helm.deploymentMethod: "native"` |\n| Use local chart | `chart.name: "./path/to/chart"` |\n| Use public chart | `chart.name: "chartname"` + `chart.repoUrl` |\n| Map env vars (array) | `envMapping.app.format: "array"` |\n| Map env vars (map) | `envMapping.app.format: "map"` |\n| Override Helm version | `helm.version: "3.14.0"` |\n| Custom Helm args | `helm.args: "--atomic --timeout 10m"` |\n| Template variables | `{{{serviceName_dockerTag}}}` |',
  },
  {
    title: "Template Variables",
    description:
      "Use dynamic template variables to reference service URLs, build metadata, and more",
    date: "2025-01-29",
    path: "docs/features/template-variables",
    body: '## Quick Reference\n\n| Variable | Example | Use For |\n|----------|---------|---------|\n| `{{{buildUUID}}}` | `lively-down-881123` | Unique environment ID |\n| `{{{_publicUrl}}}` | `api-lively-down-881123.example.com` | External service URLs |\n| `{{{_internalHostname}}}` | `api-abc123.ns.svc.cluster.local` | Service-to-service communication |\n| `{{{_sha}}}` | `0f6892` | Git commit reference |\n\n**Syntax**: Always use triple curly braces `{{{ }}}` for raw output. Double braces HTML-escape values.\n\n**Service names**: Replace hyphens with underscores (e.g., `my-api` becomes `my_api_publicUrl`).\n\n---\n\n## Common Patterns\n\n### Frontend Connecting to Backend API\n\n```yaml\nservices:\n  - name: frontend\n    github:\n      docker:\n        app:\n          env:\n            API_URL: "{{{backend_publicUrl}}}"\n```\n\n### Backend Connecting to Database\n\n```yaml\nservices:\n  - name: backend\n    github:\n      docker:\n        app:\n          env:\n            DATABASE_URL: "postgresql://{{{postgres_internalHostname}}}:5432/mydb"\n            REDIS_URL: "redis://{{{redis_internalHostname}}}:6379"\n```\n\n### Helm Values with Variables\n\n```yaml\nservices:\n  - name: myapp\n    helm:\n      chart:\n        values:\n          - "config.databaseUrl=postgresql://{{{postgres_internalHostname}}}:5432/mydb"\n```\n\n---\n\n## Wrong vs Correct Examples\n\n### Service Name with Hyphens\n\n```yaml\n# WRONG - uses hyphens in variable name\nenv:\n  API_URL: "{{{my-api_publicUrl}}}"\n\n# CORRECT - replace hyphens with underscores\nenv:\n  API_URL: "{{{my_api_publicUrl}}}"\n```\n\n### Double vs Triple Braces\n\n```yaml\n# WRONG - double braces HTML-escape special characters\nenv:\n  URL: "{{backend_publicUrl}}"\n\n# CORRECT - triple braces output raw values\nenv:\n  URL: "{{{backend_publicUrl}}}"\n```\n\n### Missing Protocol in URLs\n\n```yaml\n# WRONG - publicUrl doesn\'t include protocol\nenv:\n  ENDPOINT: "{{{backend_publicUrl}}}/api"  # Missing http://\n\n# CORRECT - add protocol when needed\nenv:\n  ENDPOINT: "https://{{{backend_publicUrl}}}/api"\n```\n\n---\n\n## Variable Categories\n\n### Build-Level Variables (Global)\n\nAvailable to all services in the environment.\n\n| Variable | Description | Example |\n|----------|-------------|---------|\n| `{{{buildUUID}}}` | Environment identifier | `lively-down-881123` |\n| `{{{buildSHA}}}` | Git SHA that triggered build | `0f6892` |\n| `{{{namespace}}}` | Kubernetes namespace | `env-lively-down-881123` |\n| `{{{pullRequestNumber}}}` | GitHub PR number | `42` |\n\n### Service-Specific Variables\n\nReplace `` with the service name (hyphens as underscores).\n\n| Variable | Active Service | Inactive Service |\n|----------|----------------|------------------|\n| `{{{_publicUrl}}}` | Build-specific URL | Falls back to `defaultPublicUrl` |\n| `{{{_internalHostname}}}` | Build-specific hostname | Falls back to `defaultInternalHostname` |\n| `{{{_UUID}}}` | Same as `buildUUID` | Falls back to `defaultUUID` |\n| `{{{_sha}}}` | Commit SHA | Empty string |\n| `{{{_branchName}}}` | Branch name | Empty string |\n| `{{{_dockerImage}}}` | `registry/app:tag` | Empty string |\n| `{{{_initDockerImage}}}` | `registry/init:tag` | Empty string |\n| `{{{_ipAddress}}}` | `10.0.0.1` | Empty string |\n\n---\n\n## Internal Hostname Format\n\n B["env-lively-down-881123"] --> C["svc.cluster.local"]\n    end\n    A -.- D["service"]\n    B -.- E["namespace"]\n    C -.- F["K8s suffix"]\n`} />\n\n**Adding suffixes and ports**:\n\n```yaml\nenv:\n  # Basic hostname\n  REDIS_HOST: "{{{redis_internalHostname}}}"\n  # redis-abc123.namespace.svc.cluster.local\n\n  # With suffix (e.g., for Redis Sentinel)\n  REDIS_MASTER: "{{{redis_internalHostname}}}-master"\n  # redis-abc123-master.namespace.svc.cluster.local\n\n  # With port\n  REDIS_URL: "{{{redis_internalHostname}}}:6379"\n  # redis-abc123.namespace.svc.cluster.local:6379\n```\n\n---\n\n## Active vs Inactive Services\n\nWhen a service is **active** (deployed in this environment):\n- Variables resolve to build-specific values\n- `{{{backend_publicUrl}}}` returns `backend-lively-down-881123.example.com`\n\nWhen a service is **inactive** (not deployed):\n- Variables fall back to configured defaults\n- `{{{backend_publicUrl}}}` returns `backend-dev-0.example.com` (static environment)\n- `{{{backend_sha}}}` returns empty string\n\n\nThis fallback behavior lets services reference optional dependencies that may point to a shared static environment when not explicitly deployed.\n\n\n---\n\n## Where Variables Work\n\n| Location | Example |\n|----------|---------|\n| Service env vars | `env: { API_URL: "{{{backend_publicUrl}}}" }` |\n| Init container env | `init: { env: { DB_HOST: "{{{postgres_internalHostname}}}" } }` |\n| Helm values | `values: ["host={{{redis_internalHostname}}}"]` |\n| Webhooks | `webhooks: [{ env: { URL: "{{{frontend_publicUrl}}}" } }]` |\n\n---\n\n## Build Output Dependencies\n\nReference another service\'s build output:\n\n```yaml\nenv:\n  API_KEY: "{{{backend_buildOutput}}}"\n```\n\n\nThis creates an implicit dependency. The service waits for the referenced service to complete its build before deploying.\n\n\n---\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| Variable resolves to empty string | Check service name spelling; hyphens must be underscores |\n| Wrong namespace in hostname | Expected for inactive services; verify service is active |\n| HTML entities in URL (`&amp;`) | Use triple braces `{{{ }}}` instead of double |\n| Variable not replaced at all | Verify variable name matches a defined service |\n\n---\n\n## Summary: When to Use Each Variable\n\n| I need to... | Use this variable |\n|--------------|-------------------|\n| Connect frontend to backend (external) | `{{{backend_publicUrl}}}` |\n| Connect backend to database (internal) | `{{{postgres_internalHostname}}}:5432` |\n| Track which build this is | `{{{buildUUID}}}` |\n| Know which commit triggered the build | `{{{buildSHA}}}` |\n| Reference the PR number | `{{{pullRequestNumber}}}` |\n| Get a service\'s Docker image | `{{{_dockerImage}}}` |\n| Wait for another service\'s build | `{{{_buildOutput}}}` |',
  },
  {
    title: "Service Dependencies",
    description: "Configure which services deploy together and in what order",
    date: "2025-01-29",
    path: "docs/features/service-dependencies",
    body: '## Quick Reference\n\nLifecycle has two dependency fields that serve different purposes:\n\n| Field | What it does | When to use |\n|-------|--------------|-------------|\n| `requires` | Includes services in the environment | "I need this service to exist" |\n| `deploymentDependsOn` | Controls deployment order | "Wait for this service before starting me" |\n\n\n**Most common pattern:** Use both fields together when your service needs another service to be running before it can start.\n\n\n```yaml\nservices:\n  - name: "api"\n    requires:\n      - name: "database"        # Include database in environment\n    deploymentDependsOn:\n      - "database"              # Wait for database before deploying\n```\n\n---\n\n## Understanding the Difference\n\n### `requires` = Environment Composition\n\nThe `requires` field answers: **"What services must exist for this service to function?"**\n\n- Adds services to the environment automatically\n- Does NOT control when services deploy\n- Follows the service everywhere (PRs, static environments, cross-repo references)\n\n### `deploymentDependsOn` = Deployment Order\n\nThe `deploymentDependsOn` field answers: **"What services must be running before this service starts?"**\n\n- Controls the order services deploy\n- Does NOT add services to the environment\n- Only affects deployment timing\n\n### Why You Often Need Both\n\n```yaml\n# WRONG - database may not be ready when api starts\nservices:\n  - name: "api"\n    requires:\n      - name: "database"    # Database is included, but...\n    # ...api might deploy before database is ready!\n\n# CORRECT - database is included AND api waits for it\nservices:\n  - name: "api"\n    requires:\n      - name: "database"    # Include database\n    deploymentDependsOn:\n      - "database"          # Wait for database\n```\n\n---\n\n## The `requires` Field\n\n### Basic Syntax\n\n```yaml\nservices:\n  - name: "api"\n    requires:\n      - name: "database"\n      - name: "cache"\n```\n\nWhen `api` is deployed, `database` and `cache` are automatically included.\n\n### Cross-Repository References\n\n```yaml\nrequires:\n  - name: "shared-auth"\n    repository: "myorg/auth-service"\n    branch: "main"\n```\n\n\n**One-level limit:** External repository dependencies only resolve one level deep.\n\n\n**What this means:**\n\n|requires| auth\n    auth -.->|requires| redis\n    auth -.-|included| api\n    redis -.-|NOT included| api\n`} />\n\nIf `auth` requires `redis`, you must explicitly add `redis` to your configuration:\n\n```yaml\nrequires:\n  - name: "auth"\n    repository: "myorg/auth-service"\n    branch: "main"\n  - name: "redis"              # Explicitly add transitive dependency\n    repository: "myorg/auth-service"\n    branch: "main"\n```\n\n---\n\n## The `deploymentDependsOn` Field\n\n### Basic Syntax\n\n```yaml\nservices:\n  - name: "api"\n    deploymentDependsOn:\n      - "database"\n      - "cache"\n```\n\nThe `api` service waits for `database` and `cache` to be ready before deploying.\n\n### How Deployment Order Works\n\nLifecycle deploys services in levels:\n\n1. **Level 0:** Services with no dependencies (deploy in parallel)\n2. **Level 1:** Services depending only on Level 0 (deploy in parallel)\n3. **Level 2:** Services depending on Level 0 or 1 (deploy in parallel)\n4. And so on...\n\n**Example:**\n\n```yaml\nservices:\n  - name: "database"           # Level 0\n\n  - name: "cache"              # Level 0\n\n  - name: "api"                # Level 1\n    deploymentDependsOn:\n      - "database"\n      - "cache"\n\n  - name: "worker"             # Level 1\n    deploymentDependsOn:\n      - "database"\n\n  - name: "frontend"           # Level 2\n    deploymentDependsOn:\n      - "api"\n```\n\n**Deployment timeline:**\n\n Level1\n    Level1 --> Level2\n`} />\n\n### Edge Cases\n\n- **Self-references:** Automatically ignored\n- **Missing services:** References to services not in the environment are ignored\n- **Circular dependencies:** Affected services won\'t deploy (no error thrown)\n\n---\n\n## Common Patterns\n\n### Pattern 1: Database with Migrations\n\n```yaml\nservices:\n  - name: "database"\n    docker:\n      dockerImage: "postgres"\n      defaultTag: "15"\n\n  - name: "migrations"\n    deploymentDependsOn:\n      - "database"\n    # Runs after database is ready\n\n  - name: "api"\n    requires:\n      - name: "database"\n    deploymentDependsOn:\n      - "migrations"\n    # Runs after migrations complete\n```\n\n### Pattern 2: Frontend with Backend\n\n```yaml\nservices:\n  - name: "backend"\n    requires:\n      - name: "database"\n      - name: "cache"\n    deploymentDependsOn:\n      - "database"\n      - "cache"\n\n  - name: "frontend"\n    deploymentDependsOn:\n      - "backend"\n    # Frontend waits for backend, but doesn\'t "require" it\n    # (frontend can run without backend for static content)\n```\n\n### Pattern 3: Cross-Repository Service\n\n```yaml\nenvironment:\n  defaultServices:\n    - name: "my-app"\n    - name: "shared-api"\n      repository: "myorg/shared-api"\n      branch: "main"\n    - name: "shared-database"      # Explicitly include transitive deps\n      repository: "myorg/shared-api"\n      branch: "main"\n\nservices:\n  - name: "my-app"\n    deploymentDependsOn:\n      - "shared-api"\n```\n\n---\n\n## Environment Configuration\n\n### Default Services\n\nServices that always deploy with the environment:\n\n```yaml\nenvironment:\n  defaultServices:\n    - name: "api"\n    - name: "database"\n```\n\n### Optional Services\n\nServices that can be toggled on/off via Mission Control:\n\n```yaml\nenvironment:\n  optionalServices:\n    - name: "debug-tools"\n    - name: "monitoring"\n```\n\n---\n\n## Troubleshooting\n\n### Service not deploying\n\n1. Is it in `defaultServices`, `optionalServices`, or another service\'s `requires`?\n2. For external repos: Did you include transitive dependencies explicitly?\n3. Check for typos in service names\n\n### Service deploys before its dependency is ready\n\nAdd the dependency to `deploymentDependsOn`, not just `requires`:\n\n```yaml\n# Add this:\ndeploymentDependsOn:\n  - "database"\n```\n\n### External service missing its dependencies\n\nThe one-level limit means you must explicitly include transitive dependencies:\n\n```yaml\nenvironment:\n  defaultServices:\n    - name: "external-api"\n      repository: "myorg/external"\n      branch: "main"\n    - name: "external-database"    # Add this explicitly\n      repository: "myorg/external"\n      branch: "main"\n```\n\n---\n\n## Summary\n\n| Question | Answer | Field |\n|----------|--------|-------|\n| "What services do I need?" | List them | `requires` |\n| "What order should services deploy?" | Specify dependencies | `deploymentDependsOn` |\n| "I need service X running before I start" | Use both | `requires` + `deploymentDependsOn` |',
  },
  {
    title: "Install Lifecycle",
    description: null,
    date: null,
    path: "docs/setup/install-lifecycle",
    body: "# Install Lifecycle\n\n## Quick Reference\n\n| Item | Value |\n|------|-------|\n| **Namespace** | `lifecycle-app` |\n| **Helm Repo** | `goodrx` → `https://goodrxoss.github.io/helm-charts` |\n| **Chart** | `goodrx/lifecycle` |\n| **Required Secrets** | `app-secrets`, `app-postgres`, `app-redis` |\n| **Components** | `lifecycle-web`, `lifecycle-worker` |\n\n## Prerequisites\n\n- Kubernetes cluster (GKE/EKS) from previous setup\n- `kubectl` configured for your cluster\n- `helm` 3.x installed\n- Namespace `lifecycle-app` created\n\n\n  Ensure your kubeconfig is updated for the target cluster before running `helm install`.\n\n\n## Installation\n\n### Step 1: Add Helm Repository\n\n```sh\nhelm repo add goodrx https://goodrxoss.github.io/helm-charts\nhelm repo update\n```\n\n### Step 2: Create Secrets\n\nCreate placeholder secrets (populated after GitHub App creation):\n\n```sh\nkubectl create secret generic app-secrets \\\n  --namespace lifecycle-app \\\n  --from-literal=GITHUB_PRIVATE_KEY=\"\" \\\n  --from-literal=GITHUB_CLIENT_SECRET=\"\" \\\n  --from-literal=GITHUB_WEBHOOK_SECRET=\"\" \\\n  --from-literal=GITHUB_APP_ID=\"\" \\\n  --from-literal=GITHUB_CLIENT_ID=\"\" \\\n  --from-literal=GITHUB_APP_INSTALLATION_ID=\"\" \\\n  --dry-run=client -o yaml | kubectl apply -f -\n```\n\n### Step 3: Configure Values\n\nCreate `values.yaml`:\n\n```yaml values.yaml\nglobal:\n  image:\n    repository: lifecycleoss/app\n    tag: latest\n    pullPolicy: IfNotPresent\n\n  env:\n    - name: JOB_VERSION\n      value: default\n    - name: ENVIRONMENT\n      value: production\n    - name: NODE_ENV\n      value: production\n    - name: APP_ENV\n      value: production\n    - name: PORT\n      value: '80'\n    - name: DATABASE_URL\n      valueFrom:\n        secretKeyRef:\n          name: app-postgres\n          key: DATABASE_URL\n    - name: REDIS_URL\n      valueFrom:\n        secretKeyRef:\n          name: app-redis\n          key: REDIS_URL\n  envFrom:\n    - secretRef:\n        name: app-secrets\n\ncomponents:\n  web:\n    enabled: true\n    fullnameOverride: 'lifecycle-web'\n    service:\n      enabled: true\n      type: ClusterIP\n      port: 80\n    ingress:\n      enabled: true\n      ingressClassName: nginx\n      annotations:\n        cert-manager.io/cluster-issuer: letsencrypt\n      hosts:\n        - host: app.  # Replace with your domain\n          paths: ['/']\n    deployment:\n      replicaCount: 1\n      resources:\n        requests:\n          cpu: 200m\n          memory: 200Mi\n\n  worker:\n    enabled: true\n    fullnameOverride: 'lifecycle-worker'\n    service:\n      enabled: false\n    ingress:\n      enabled: false\n    deployment:\n      replicaCount: 1\n      resources:\n        limits:\n          cpu: 1000m\n          memory: 4000Mi\n        requests:\n          cpu: 200m\n          memory: 200Mi\n      extraEnv:\n        - name: LIFECYCLE_MODE\n          value: job\n        - name: LOG_LEVEL\n          value: info\n        - name: MAX_GITHUB_API_REQUEST\n          value: '40'\n        - name: GITHUB_API_REQUEST_INTERVAL\n          value: '10000'\n\n# Enable only if NOT using external services\npostgresql:\n  enabled: false\nredis:\n  enabled: false\n\nrbac:\n  create: true\n\nsecrets:\n  enabled: true\n```\n\n### Step 4: Install Chart\n\n```sh\nhelm install lifecycle goodrx/lifecycle \\\n  --namespace lifecycle-app \\\n  --values values.yaml\n```\n\nSee also: [Lifecycle Helm chart documentation](https://github.com/GoodRxOSS/helm-charts/blob/main/charts/lifecycle/README.md)\n\n### Step 5: Verify Installation\n\n```sh\nkubectl get pods -n lifecycle-app\n```\n\n**Expected output:**\n\n```\nNAME                               READY   STATUS    RESTARTS   AGE\nlifecycle-web-xxxxx-xxxxx          1/1     Running   0          2m\nlifecycle-worker-xxxxx-xxxxx       1/1     Running   0          2m\n```\n\nAccess the application at your configured domain (e.g., `https://app.0env.com`).\n\n\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| **Certificate not ready** | Check status: `kubectl get certificate -n lifecycle-app` — wait for `Ready` state or verify DNS settings |\n| **Pods not starting** | Check logs: `kubectl logs -n lifecycle-app -l app=lifecycle-web` |\n| **Database connection fails** | Verify secret: `kubectl get secret app-postgres -n lifecycle-app -o jsonpath='{.data.DATABASE_URL}' \\| base64 -d` |\n\n\n\n## Summary Checklist\n\n- [ ] Helm repo added and updated\n- [ ] `app-secrets` secret created\n- [ ] `values.yaml` configured with your domain\n- [ ] Helm chart installed\n- [ ] Both pods running (`lifecycle-web`, `lifecycle-worker`)\n- [ ] Certificate in `Ready` state\n- [ ] Application accessible at configured domain\n\n---\n\n**Next:** Create a GitHub App to connect Lifecycle with your repositories.",
  },
  {
    title: "Prerequisites",
    description: null,
    date: null,
    path: "docs/setup/prerequisites",
    body: '## Quick Reference\n\n| Requirement | Options | Install/Sign Up |\n|-------------|---------|-----------------|\n| **GitHub Account** | Personal or Organization | [github.com/join](https://github.com/join) |\n| **Cloud Provider** | GKE or AWS | [Google Cloud](https://cloud.google.com) / [AWS](https://aws.amazon.com/) |\n| **CLI: OpenTofu** | Infrastructure as code | [opentofu.org](https://opentofu.org/docs/intro/install/) |\n| **CLI: kubectl** | Kubernetes management | [kubernetes.io](https://kubernetes.io/docs/tasks/tools/#kubectl) |\n| **CLI: Helm** | K8s package manager | [helm.sh](https://helm.sh/docs/intro/install/) |\n| **CLI: gcloud/aws** | Cloud provider CLI | [gcloud](https://formulae.brew.sh/cask/google-cloud-sdk) / [aws-cli](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html) |\n| **Custom Domain** | With wildcard support | Your registrar |\n\n\n  Use an isolated cloud project/account for this setup to keep resources organized.\n\n\n## Domain Requirements\n\nYour domain (e.g., `0env.com`) must support wildcard DNS records (e.g., `*.0env.com`).\n\n**Used for:**\n- GitHub App webhook/callback URLs\n- Kubernetes ingress routing\n- HTTPS/TLS certificates\n\n(Lifecycle App)"]\n        pr123["pr-123.0env.com(Ephemeral Env)"]\n        pr456["pr-456.0env.com(Ephemeral Env)"]\n\n        wildcard --> lifecycle\n        wildcard --> pr123\n        wildcard --> pr456\n    end\n`} />\n\n## DNS Provider Setup\n\n\n\n\n### Option 1: Console\n\n1. Go to [Google Cloud DNS](https://cloud.google.com/dns)\n2. [Create a public DNS zone](https://cloud.google.com/dns/docs/zones#create-pub-zone)\n3. Wildcard records are created automatically by OpenTofu modules\n\n### Option 2: CLI\n\n```sh\n# Set project and authenticate\ngcloud config set project \ngcloud auth application-default login\n\n# Enable DNS API and create zone\ngcloud services enable dns.googleapis.com --project=\ngcloud dns --project= managed-zones create  \\\n  --description="Lifecycle OSS starter DNS public zone" \\\n  --dns-name="." \\\n  --visibility="public" \\\n  --dnssec-state="off"\n```\n\nUpdate your registrar\'s NS records with the values from Google Cloud Console.\n\n\n\n### Option 1: Console\n\n1. Authenticate with AWS CLI: `aws configure`\n2. [Provision wildcard subdomain](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/CreatingNewSubdomain.html) (e.g., `*.lifecycle..com`)\n\n### Option 2: CLI\n\n```sh\naws configure\n```\n\n```sh\naws route53 change-resource-record-sets --hosted-zone-id  --change-batch \'{\n  "Comment": "CREATE wildcard for ",\n  "Changes": [{\n    "Action": "CREATE",\n    "ResourceRecordSet": {\n      "Name": "..com",\n      "Type": "A",\n      "TTL": 300,\n      "ResourceRecords": [{ "Value": "" }]\n    }\n  }]\n}\'\n```\n\n\n\nUse Cloudflare as your authoritative DNS (full setup required).\n\nFollow the [Cloudflare full setup guide](https://developers.cloudflare.com/dns/zone-setups/full-setup/setup/).\n\n\n\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| DNS not resolving | Verify NS records at registrar point to your DNS provider |\n| Propagation delay | Wait up to 48 hours; check status at [dnschecker.org](https://dnschecker.org/#NS) |\n| Wildcard not working | Ensure `*.` record exists in your DNS zone |\n\n## Checklist\n\n- [ ] GitHub account created\n- [ ] Cloud provider account set up (isolated project recommended)\n- [ ] CLI tools installed: OpenTofu, kubectl, Helm, gcloud/aws-cli\n- [ ] Custom domain registered\n- [ ] DNS zone created with wildcard support\n- [ ] NS records updated at registrar\n- [ ] DNS propagation verified at [dnschecker.org](https://dnschecker.org/#NS)',
  },
  {
    title: "Setup your cluster",
    description: null,
    date: null,
    path: "docs/setup/setup-infra",
    body: '## Quick Reference\n\n| Provider | Cluster Type | DNS Options | Required Permissions |\n|----------|-------------|-------------|---------------------|\n| GCP | GKE | cloud-dns, cloudflare, route53 | Project Owner or Editor |\n| AWS | EKS | route53, cloudflare, cloud-dns | AdministratorAccess |\n\n\n  **Security Warning:** This setup opens your cluster to the internet. Implement network policies and access controls after initial setup.\n\n\n## Setup Overview\n\n B[Clone\\nlifecycle-opentofu repo]\n    B --> C[Configure\\nsecrets.auto.tfvars]\n    C --> D[tofu init]\n    D --> E[tofu plan]\n    E --> F[tofu apply]\n    F --> G[Verify with curl\\nhttps://kuard.YOUR_DOMAIN]\n`} />\n\n**Resources created:** Kubernetes cluster, DNS records, database, Redis, and supporting infrastructure.\n\n---\n\n## Google Cloud Platform\n\n### 1. Configure Credentials\n\n```sh\ngcloud config set project \ngcloud auth application-default login\ngcloud services enable container.googleapis.com dns.googleapis.com --project=\n```\n\n\n  Use your Google Cloud **project ID** (not project name).\n\n\n### 2. Deploy Infrastructure\n\n```sh\ngit clone https://github.com/GoodRxOSS/lifecycle-opentofu/ && cd lifecycle-opentofu\ncp example.auto.tfvars secrets.auto.tfvars\n```\n\nEdit `secrets.auto.tfvars`:\n\n```hcl secrets.auto.tfvars\ngcp_project          = ""\ngcp_region           = ""\ngcp_credentials_file = "~/.config/gcloud/application_default_credentials.json"\ncluster_provider     = "gke"\ndns_provider         = "cloud-dns"     # Options: cloudflare, route53, cloud-dns\napp_domain           = "" # e.g., 0env.com\ncluster_name         = "lifecycle-gke"\napp_namespace        = "lifecycle-app"\n```\n\n```sh\ntofu init && tofu plan && tofu apply\n```\n\n### 3. Verify Setup\n\n```sh\ncurl -v https://kuard.\n```\n\nSee [example output](https://github.com/GoodRxOSS/lifecycle-opentofu/?tab=readme-ov-file#4-initialize--apply) for kubeconfig setup.\n\n\n}\n  title="Install Lifecycle"\n  href="/docs/setup/install-lifecycle"\n  arrow\n/>\n\n---\n\n## Amazon Web Services\n\n### 1. Configure Credentials\n\n```sh\naws configure --profile lifecycle-oss-eks\n```\n\nEnter your Access Key ID, Secret Access Key, Region, and output format when prompted.\n\n\n  Profile requires **AdministratorAccess** permissions.\n\n\n### 2. Deploy Infrastructure\n\n```sh\ngit clone https://github.com/GoodRxOSS/lifecycle-opentofu/ && cd lifecycle-opentofu\ncp example.auto.tfvars secrets.auto.tfvars\n```\n\nEdit `secrets.auto.tfvars`:\n\n```hcl secrets.auto.tfvars\naws_region           = ""\ncluster_provider     = "eks"\ndns_provider         = "route53"       # Options: cloudflare, route53, cloud-dns\napp_domain           = "" # e.g., 0env.com\ncluster_name         = "lifecycle-eks"\napp_namespace        = "lifecycle-app"\n```\n\n```sh\ntofu init && tofu plan && tofu apply\n```\n\n### 3. Verify Setup\n\n```sh\ncurl -v https://kuard.\n```\n\nSee [example output](https://github.com/GoodRxOSS/lifecycle-opentofu/?tab=readme-ov-file#4-initialize--apply) for kubeconfig setup.\n\n\n}\n  title="Install Lifecycle"\n  href="/docs/setup/install-lifecycle"\n  arrow\n/>\n\n---\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| `tofu apply` fails with permission error | Verify credentials have required permissions (GCP: Owner/Editor, AWS: AdministratorAccess) |\n| DNS not resolving | Wait 5-10 minutes for propagation; verify domain ownership |\n| `curl` returns connection refused | Check cluster ingress controller is running: `kubectl get pods -n ingress-nginx` |\n| kuard not accessible | Verify DNS records in your provider\'s console |\n\n---\n\n## Setup Checklist\n\n- [ ] Cloud credentials configured\n- [ ] Required APIs/services enabled\n- [ ] `secrets.auto.tfvars` configured with your values\n- [ ] `tofu apply` completed successfully\n- [ ] `curl https://kuard.` returns a response\n- [ ] kubeconfig configured for cluster access\n- [ ] Network policies reviewed for security',
  },
  {
    title: "Additional Configuration",
    description: null,
    date: null,
    path: "docs/setup/configure-lifecycle",
    body: "## Quick Reference\n\n| Task | Command/Action |\n|------|----------------|\n| Get DB credentials | `kubectl get secret app-postgres -n lifecycle-app -o jsonpath='{.data}' \\| jq 'with_entries(.value \\|= @base64d)'` |\n| Refresh config cache | `curl -X PUT https://app./api/v1/config/cache` |\n| Access UI | `https://app.` |\n\n---\n\n## Set Default IP Whitelist\n\n\n  **Security Warning:** Infrastructure setup opens your cluster to the world (`0.0.0.0/0`).\n  Replace `defaultIPWhiteList` with your actual CIDR blocks immediately after setup.\n\n\n### Configuration Flow\n\n B[Run SQL Query] --> C[Refresh Cache]\n`} />\n\n### Step 1: Get Database Credentials\n\n```sh\nkubectl get secret app-postgres --namespace lifecycle-app \\\n   -o jsonpath='{.data}' | jq 'with_entries(.value |= @base64d)'\n```\n\n### Step 2: Update IP Whitelist\n\nConnect to the `postgres` database and run:\n\n```sql\nUPDATE public.global_config\nSET\n    config = (config::jsonb || '{\"defaultIPWhiteList\": \"{ 10.0.0.0/8, 192.168.1.0/24 }\"}'::jsonb)::json,\n    \"updatedAt\" = NOW()\nWHERE \"key\" = 'serviceDefaults';\n```\n\n| Example CIDR | Access Level |\n|--------------|--------------|\n| `0.0.0.0/0` | Open to all (insecure) |\n| `10.0.0.0/8` | Private network |\n| `203.0.113.50/32` | Single IP |\n\n### Step 3: Refresh Configuration Cache\n\n```sh\ncurl -X PUT https://app./api/v1/config/cache\n```\n\n---\n\n## Environment Variables\n\n### Database\n\n| Variable | Description | Default |\n|----------|-------------|---------|\n| `APP_DB_HOST` | PostgreSQL host | `localhost` |\n| `APP_DB_PORT` | PostgreSQL port | `5432` |\n| `APP_DB_USER` | Username | `lifecycle` |\n| `APP_DB_PASSWORD` | Password | - |\n| `APP_DB_NAME` | Database name | `lifecycle` |\n| `APP_DB_SSL` | Enable SSL | `false` |\n\n### Redis\n\n| Variable | Description | Default |\n|----------|-------------|---------|\n| `APP_REDIS_HOST` | Redis host | `localhost` |\n| `APP_REDIS_PORT` | Redis port | `6379` |\n| `APP_REDIS_PASSWORD` | Password | - |\n| `APP_REDIS_TLS` | Enable TLS | `false` |\n\n### GitHub\n\n| Variable | Description | Default |\n|----------|-------------|---------|\n| `GITHUB_APP_ID` | GitHub App ID | - |\n| `GITHUB_CLIENT_ID` | Client ID | - |\n| `GITHUB_CLIENT_SECRET` | Client secret | - |\n| `GITHUB_PRIVATE_KEY` | Private key (PEM) | - |\n| `GITHUB_WEBHOOK_SECRET` | Webhook secret | - |\n| `GITHUB_APP_INSTALLATION_ID` | Installation ID | - |\n| `MAX_GITHUB_API_REQUEST` | Max API requests per interval | `40` |\n| `GITHUB_API_REQUEST_INTERVAL` | Rate limit interval (ms) | `10000` |\n\n### Application\n\n| Variable | Description | Default |\n|----------|-------------|---------|\n| `APP_ENV` | Environment | `development` |\n| `LIFECYCLE_MODE` | Mode (`web`, `job`, `all`) | `all` |\n| `PORT` | HTTP port | `3000` |\n| `LOG_LEVEL` | Log level | `debug` |\n| `LIFECYCLE_UI_HOSTHAME_WITH_SCHEME` | Public UI URL | - |\n\n### Observability (Datadog)\n\n| Variable | Description | Default |\n|----------|-------------|---------|\n| `DD_ENV` | Environment tag | `prd` |\n| `DD_SERVICE` | Service name | `lifecycle-job` |\n| `DD_VERSION` | Version tag | `lifecycle` |\n\n### Authentication (Optional)\n\n| Variable | Description |\n|----------|-------------|\n| `KEYCLOAK_ISSUER` | Keycloak issuer URL |\n| `KEYCLOAK_CLIENT_ID` | Keycloak client ID |\n| `KEYCLOAK_JWKS_URL` | Keycloak JWKS URL |\n| `ALLOWED_ORIGINS` | Allowed CORS origins (comma-separated) |\n\n---\n\n## Global Configuration (Database)\n\nConfiguration stored in `global_config` table:\n\n### Service Defaults (`serviceDefaults`)\n\n| Setting | Description |\n|---------|-------------|\n| `defaultIPWhiteList` | IP whitelist for deployed services |\n| `cpuRequest` / `memoryRequest` | Default resource requests |\n| `readinessInitialDelaySeconds` | Readiness probe initial delay |\n| `readinessPeriodSeconds` | Readiness probe period |\n| `readinessTimeoutSeconds` | Readiness probe timeout |\n| `readinessSuccessThreshold` | Success threshold |\n| `readinessFailureThreshold` | Failure threshold |\n\n### Build Defaults (`buildDefaults`)\n\n| Setting | Description |\n|---------|-------------|\n| `buildkit.endpoint` | BuildKit service endpoint |\n\n### Feature Flags (`features`)\n\n| Setting | Description | Default |\n|---------|-------------|---------|\n| `webhooks` | Enable webhook execution | `true` |\n\n---\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| Config changes not applied | Run `curl -X PUT https://app./api/v1/config/cache` |\n| Cannot get DB credentials | Verify `lifecycle-app` namespace exists and secret is present |\n| UI not accessible | Check ingress configuration and DNS settings |\n\n---\n\n## Verification Checklist\n\n- [ ] Access Lifecycle UI at `https://app.`\n- [ ] GitHub App shows connected\n- [ ] Create test PR with `lifecycle.yaml` file\n- [ ] Add `lifecycle-deploy!` label to PR\n- [ ] Environment creation visible in UI\n\nSetup complete. You're ready to create ephemeral environments.",
  },
  {
    title: "Create GitHub App",
    description: null,
    date: null,
    path: "docs/setup/create-github-app",
    body: "## Quick Reference\n\n| Item | Value |\n|------|-------|\n| **Setup URL** | `https://app./setup` |\n| **Webhook URL** | `https://app./api/webhooks/github` |\n| **BuildKit Port** | `1234` |\n| **Namespace** | `lifecycle-app` |\n\n(DB)\"] --> B[\"2. Create App(Wizard)\"] --> C[\"3. Install(Repos)\"]\n`} />\n\n---\n\n## Step 1: Configure BuildKit Endpoint\n\nBuildKit builds container images for your services. Configure the endpoint before creating the GitHub App.\n\n\n  Set `HELM_RELEASE` to your actual Helm release name before running commands.\n\n\n### Option A: kubectl + psql\n\n```bash\n# Set your Helm release name\nexport HELM_RELEASE=\n\n# Get database password\nexport PGPASSWORD=$(kubectl get secret ${HELM_RELEASE}-postgres -n lifecycle-app -o jsonpath='{.data.POSTGRES_USER_PASSWORD}' | base64 -d)\n\n# Update BuildKit endpoint\nkubectl exec -it ${HELM_RELEASE}-postgres-0 -n lifecycle-app -- env PGPASSWORD=$PGPASSWORD psql -U lifecycle -d lifecycle -c \"\nUPDATE global_config\nSET config = jsonb_set(\n    jsonb_set(\n        COALESCE(config::jsonb, '{}'::jsonb),\n        '{buildkit}',\n        COALESCE(config::jsonb->'buildkit', '{}'::jsonb),\n        true\n    ),\n    '{buildkit,endpoint}',\n    '\\\"tcp://${HELM_RELEASE}-buildkit.lifecycle-app.svc.cluster.local:1234\\\"'::jsonb,\n    true\n),\n\\\"updatedAt\\\" = NOW()\nWHERE key = 'buildDefaults';\"\n```\n\n### Option B: Direct SQL\n\n```sql\nUPDATE global_config\nSET config = jsonb_set(\n    jsonb_set(\n        COALESCE(config::jsonb, '{}'::jsonb),\n        '{buildkit}',\n        COALESCE(config::jsonb->'buildkit', '{}'::jsonb),\n        true\n    ),\n    '{buildkit,endpoint}',\n    '\"tcp://-buildkit.lifecycle-app.svc.cluster.local:1234\"'::jsonb,\n    true\n),\n\"updatedAt\" = NOW()\nWHERE key = 'buildDefaults';\n```\n\n### Refresh Cache\n\n```bash\ncurl -X 'PUT' 'https://app./api/v1/config/cache' -H 'accept: application/json'\n```\n\n---\n\n## Step 2: Create GitHub App\n\n\n  Requires admin access to the target GitHub organization or account.\n\n\n### Using the Setup Wizard\n\n1. Navigate to `https://app./setup`\n\n\n\n2. Select **Personal** or **Organization**\n\n3. Fill in required fields:\n\n| Field | Description | Example |\n|-------|-------------|---------|\n| GitHub App Name | Unique identifier ([naming conventions](https://docs.github.com/en/apps/creating-github-apps/registering-a-github-app/)) | `myorg-lifecycle-dev` |\n| Organization Name | GitHub org (required for Organization type) | `myorg` |\n\n4. Click **Create App** → Confirm on GitHub → Select repositories\n\n\n  You must select at least one repository to proceed with setup.\n\n\n5. Click **Configure and Restart** to apply changes\n\n\n\n---\n\n## Permissions & Events\n\n### Repository Permissions\n\n| Permission | Access | Purpose |\n|------------|--------|---------|\n| Contents | Read | Access `lifecycle.yaml` config |\n| Deployments | Write | Manage environment deployments |\n| Issues | Write | Comment on pull requests |\n| Metadata | Read | Repository metadata |\n| Pull Requests | Write | Read PR data, create comments |\n| Statuses | Read | Read commit status checks |\n\n### Organization Permissions\n\n| Permission | Access | Purpose |\n|------------|--------|---------|\n| Members | Read | Organization membership info |\n\n### Webhook Events\n\n| Event | Trigger |\n|-------|---------|\n| `pull_request` | PR opened, closed, reopened, synchronized |\n| `push` | Commits pushed to branch |\n| `issue_comment` | Comments on issues/PRs |\n| `label` | Labels added/removed |\n| `issues` | Issues opened, edited, closed |\n| `repository` | Repo created, deleted, modified |\n| `membership` | Org membership changes |\n| `organization` | Org settings changes |\n| `team` | Teams created, deleted, modified |\n| `public` | Repo made public |\n\n---\n\n## Manual Setup (Alternative)\n\n\nClick to expand manual GitHub App creation steps\n\n1. Go to **GitHub Settings** → **Developer settings** → **GitHub Apps** → **New GitHub App**\n\n2. Configure:\n   - **Homepage URL**: `https://app.`\n   - **Webhook URL**: `https://app./api/webhooks/github`\n   - **Webhook secret**: Generate secure random string\n\n3. Set permissions and events per tables above\n\n4. After creation, collect these values:\n   - App ID\n   - Client ID\n   - Client secret\n   - Private key (`.pem` file)\n   - Webhook secret\n   - Installation ID\n\n5. Create Kubernetes secret:\n\n```sh\nkubectl create secret generic app-secrets \\\n  --namespace lifecycle-app \\\n  --from-literal=GITHUB_APP_ID= \\\n  --from-literal=GITHUB_CLIENT_ID= \\\n  --from-literal=GITHUB_CLIENT_SECRET= \\\n  --from-literal=GITHUB_WEBHOOK_SECRET= \\\n  --from-literal=GITHUB_PRIVATE_KEY=\"$(cat )\" \\\n  --from-literal=GITHUB_APP_INSTALLATION_ID= \\\n  --dry-run=client -o yaml | kubectl apply -f -\n```\n\n6. Restart deployments:\n\n```sh\nkubectl rollout restart deployment -n lifecycle-app\n```\n\n\n\n---\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| BuildKit endpoint not updating | Verify `HELM_RELEASE` matches your actual release name |\n| Cache refresh fails | Check that app domain is correct and accessible |\n| App creation fails | Ensure admin access to GitHub org/account |\n| No repositories shown | Install app on at least one repository |\n| Webhooks not received | Verify webhook URL and secret match configuration |\n\n---\n\n## Checklist\n\n- [ ] Set `HELM_RELEASE` environment variable\n- [ ] Configure BuildKit endpoint in database\n- [ ] Refresh configuration cache\n- [ ] Create GitHub App via setup wizard\n- [ ] Select repositories for app installation\n- [ ] Click \"Configure and Restart\"\n- [ ] Verify app appears in GitHub settings\n\n---\n\nProceed to configure additional Lifecycle settings.",
  },
  {
    title: "Deployment Issues",
    description: "Troubleshooting common deployment problems in Lifecycle",
    date: "2025-01-29",
    path: "docs/troubleshooting/deploy-issues",
    body: '## Quick Reference\n\n| Problem | Likely Cause | Quick Fix |\n|---------|--------------|-----------|\n| **Build Failed** | Dockerfile error, missing deps | Check build logs, test `docker build` locally |\n| **ImagePullBackOff** | Image not found or auth failed | Verify image exists, check registry credentials |\n| **CrashLoopBackOff** | App crashes on startup | Check container logs, fix startup issues |\n| **OOMKilled** | Memory limit exceeded | Increase `memory.limit` in config |\n| **Pending** | Insufficient cluster resources | Lower resource requests or contact admin |\n| **Deploy Failed** | Invalid config or Helm error | Check deploy logs, validate `lifecycle.yaml` |\n\n\n**Pods must pass health checks within 15 minutes** or deployment fails. Check readiness probe configuration if timing out.\n\n\n---\n\n## Deployment Status Flow\n\n```\nQueued -> Cloning -> Building -> Built -> Waiting -> Deploying -> Ready\n                        |                               |\n                        v                               v\n                   Build Failed                   Deploy Failed\n```\n\n| Status | Meaning |\n|--------|---------|\n| **Queued** | Waiting in queue |\n| **Cloning** | Pulling source code |\n| **Building** | Building Docker image |\n| **Built** | Image ready |\n| **Waiting** | Dependencies not ready |\n| **Deploying** | Rolling out to K8s |\n| **Ready** | Healthy and serving |\n| **Build Failed** | Docker build error |\n| **Deploy Failed** | K8s deployment error |\n| **Torn Down** | Environment deleted |\n\n---\n\n## Build Failures\n\n### Problem: Build Failed Status\n\n**Check build logs first** - 90% of issues are visible there.\n\n| Cause | Solution |\n|-------|----------|\n| Dockerfile syntax error | Test locally: `docker build -t test .` |\n| Missing base image | Verify image exists in registry |\n| Package install failed | Check network access, package versions |\n| Registry push failed | Verify ECR/registry credentials |\n\n### Problem: Git SHA Not Found\n\n```\n# WRONG: Branch not pushed\ngit commit -m "fix"\n# (forgot to push)\n\n# CORRECT: Push before deploying\ngit commit -m "fix"\ngit push origin feature-branch\n```\n\n**Checklist:**\n- Branch exists on remote (not just local)\n- Commit SHA is pushed\n- GitHub App has repository access\n\n### Problem: ECR Configuration Missing\n\nContact your administrator to:\n1. Create ECR repository for your service\n2. Configure registry in Lifecycle\n3. Verify IAM permissions\n\n---\n\n## Pod Failures\n\n### Diagnosing Pod Issues\n\n```\nPod Status           Meaning                    Action\n-----------          -------                    ------\nImagePullBackOff  -> Can\'t pull image        -> Check image name, registry auth\nCrashLoopBackOff  -> App keeps crashing      -> Check app logs, fix startup bug\nOOMKilled         -> Out of memory           -> Increase memory.limit\nPending           -> Can\'t schedule          -> Lower resource requests\n```\n\n### Problem: OOMKilled\n\n```yaml\n# WRONG: Memory limit too low\ndeployment:\n  resource:\n    memory:\n      request: "64Mi"\n      limit: "128Mi"    # App needs more\n\n# CORRECT: Match your app\'s actual needs\ndeployment:\n  resource:\n    memory:\n      request: "256Mi"\n      limit: "512Mi"\n```\n\n### Problem: Pods Stuck Pending\n\n```yaml\n# WRONG: Requesting more than cluster has\ndeployment:\n  resource:\n    cpu:\n      request: "4000m"   # 4 CPUs - too high\n    memory:\n      request: "8Gi"     # 8GB - too high\n\n# CORRECT: Use reasonable defaults\ndeployment:\n  resource:\n    cpu:\n      request: "100m"\n      limit: "500m"\n    memory:\n      request: "256Mi"\n      limit: "512Mi"\n```\n\n---\n\n## Helm Deployment Issues\n\n### Problem: Helm Deployment Failed\n\n| Error | Cause | Fix |\n|-------|-------|-----|\n| Chart not found | Bad name/URL | Verify `chart.name` and `repoUrl` |\n| Version not found | Invalid version | Check available versions in repo |\n| Invalid values | YAML syntax error | Validate values syntax |\n| Release blocked | Previous op stuck | Wait or contact admin |\n\n### Blocked Release States\n\n| State | What Happened | Resolution |\n|-------|---------------|------------|\n| `pending-install` | Install interrupted | Auto-cleanup by Lifecycle |\n| `pending-upgrade` | Upgrade interrupted | Auto-cleanup by Lifecycle |\n| `pending-rollback` | Rollback interrupted | Auto-cleanup by Lifecycle |\n| `failed` | Operation failed | Auto-retry by Lifecycle |\n\n\nLifecycle automatically detects and cleans up stuck Helm releases.\n\n\n### Helm Configuration Examples\n\n```yaml\n# WRONG: Missing required fields\nhelm:\n  chart:\n    name: "my-chart"\n    # Missing version for public chart!\n    repoUrl: "https://charts.example.com"\n\n# CORRECT: All required fields present\nhelm:\n  chart:\n    name: "my-chart"\n    version: "1.2.3"\n    repoUrl: "https://charts.example.com"\n```\n\n---\n\n## Network & Ingress Issues\n\n### Problem: Service Deployed but URL Not Accessible\n\n**Checklist:**\n\n| Check | How |\n|-------|-----|\n| Service marked public? | Verify `public: true` in config |\n| Hostname correct? | Check hostname configuration |\n| Ingress working? | Check ingress controller status |\n| DNS configured? | Verify DNS record exists |\n| TLS valid? | Check certificate expiration |\n\n```yaml\n# WRONG: Service not exposed\nservices:\n  my-api:\n    # Missing public setting\n\n# CORRECT: Service exposed publicly\nservices:\n  my-api:\n    public: true\n    hostname: "my-api.example.com"\n```\n\n---\n\n## Database Issues (Aurora)\n\n### Problem: Aurora Restore Failed\n\n| Cause | Solution |\n|-------|----------|\n| Snapshot doesn\'t exist | Verify exact snapshot name |\n| Permission denied | Check IAM RDS permissions |\n| Region mismatch | Snapshot must be in same region as cluster |\n\n---\n\n## Accessing Logs\n\n| Log Type | Location |\n|----------|----------|\n| **Build Logs** | Dashboard -> Environment -> Service -> Build Logs |\n| **Deploy Logs** | PR with `lifecycle-status-comments!` label -> Click "Deploy Logs" link |\n| **Container Logs** | Dashboard -> Environment -> Service -> Container Logs |\n\n---\n\n## Troubleshooting Checklist\n\nWhen deployment fails, work through this list:\n\n```\n1. BUILD OK?\n   |-- No  -> Check build logs, test Dockerfile locally\n   |-- Yes -> Continue\n\n2. IMAGE PULL OK?\n   |-- No  -> ImagePullBackOff? Check registry auth\n   |-- Yes -> Continue\n\n3. RESOURCES OK?\n   |-- No  -> Pending? Lower resource requests\n   |-- Yes -> Continue\n\n4. APP HEALTHY?\n   |-- No  -> CrashLoopBackOff? Check app logs\n   |-- Yes -> Continue\n\n5. NETWORK OK?\n   |-- No  -> Check public: true, hostname, ingress\n   |-- Yes -> Should be working!\n```\n\n---\n\n## Getting Help\n\n**Before contacting support, collect:**\n\n- Build UUID or Environment ID\n- Service name\n- Error messages (copy from logs)\n- Steps to reproduce\n\n**Resources:**\n- Configuration guides in this documentation\n- Schema reference for valid field names\n- Your Lifecycle administrator for cluster issues\n\n---\n\n## Summary\n\n| Issue | First Step |\n|-------|------------|\n| Build Failed | Check build logs, test Docker locally |\n| ImagePullBackOff | Verify image name and registry credentials |\n| CrashLoopBackOff | Check container logs for crash reason |\n| OOMKilled | Increase `memory.limit` |\n| Pending | Lower resource requests |\n| Helm Failed | Check deploy logs for specific error |\n| URL Not Working | Verify `public: true` and hostname |\n| Aurora Failed | Verify snapshot name and region |',
  },
  {
    title: "GitHub App Webhooks",
    description: "Troubleshoot GitHub App webhook issues in Lifecycle",
    date: "2025-01-29",
    path: "docs/troubleshooting/github-app-webhooks",
    body: '## Quick Reference\n\n| Symptom | Likely Cause | Quick Fix |\n|---------|--------------|-----------|\n| No PR comments | Webhook not delivered | Check GitHub App > Advanced > Recent Deliveries |\n| No deployment | Missing `lifecycle-deploy!` label | Add label to PR |\n| HTTP 500 errors | Webhook secret mismatch | Sync secret between GitHub App and Kubernetes |\n| Webhook timeout | Service unavailable | Check pod status and restart deployments |\n| Events ignored | Wrong events enabled | Enable Pull requests, Push, Issue comments |\n\n---\n\n## Required Configuration\n\n### Webhook URL Format\n\n```\nCORRECT:  https://your-lifecycle-domain.com/api/webhooks/github\n```\n\n| Mistake | Example |\n|---------|---------|\n| Missing path | `https://domain.com` |\n| HTTP instead of HTTPS | `http://domain.com/api/webhooks/github` |\n| Trailing slash | `https://domain.com/api/webhooks/github/` |\n\n### Required Events\n\n| Event | What It Does |\n|-------|--------------|\n| Pull requests | Creates/destroys environments on PR open/close |\n| Push | Triggers rebuilds when code is pushed |\n| Issue comments | Enables configuration changes via comments |\n\nLabel events (`labeled`, `unlabeled`) control:\n- `lifecycle-deploy!` - Enable deployments\n- `lifecycle-disabled!` - Disable deployments\n- `lifecycle-keep!` - Preserve environments\n\n---\n\n## Problem → Solution\n\n### No PR Comments Appearing\n\n B[Webhook URL]\n    B --> C[Lifecycle Web]\n    C --> D[PR Comment]\n    A -.-> E["Check here"]\n    B -.-> F["Check URL"]\n    C -.-> G["Check logs"]\n`} />\n\n1. **Verify webhook delivery**: GitHub App > Advanced > Recent Deliveries\n2. **Confirm installation**: Repository Settings > Integrations > GitHub Apps\n3. **Check deploy label**: Comments only appear on PRs with `lifecycle-deploy!`\n\n### Deployments Not Triggering\n\n| Check | Command/Action |\n|-------|----------------|\n| Deploy label present? | Add `lifecycle-deploy!` label |\n| Disabled label? | Remove `lifecycle-disabled!` if present |\n| Bot PR? | PRs from bot accounts are ignored |\n| Webhook delivered? | Check Recent Deliveries in GitHub App |\n\n### Push Events Not Rebuilding\n\nRequirements for push-triggered rebuilds:\n1. PR must be open\n2. PR must have `lifecycle-deploy!` label\n3. Pushed branch must match tracked deployment\n4. Push webhook must be delivered successfully\n\n### Webhook Secret Mismatch (HTTP 500 Errors)\n\n**Symptoms:**\n- All deliveries return HTTP 500\n- Logs show "Webhook not verified"\n\n**Verify the secret:**\n\n```bash\nkubectl get secret app-secrets --namespace lifecycle-app \\\n  -o jsonpath=\'{.data.GITHUB_WEBHOOK_SECRET}\' | base64 -d\n```\n\n**Fix mismatched secret:**\n\n```bash\n# Update secret\nkubectl create secret generic app-secrets \\\n  --namespace lifecycle-app \\\n  --from-literal=GITHUB_WEBHOOK_SECRET=your-new-secret \\\n  --dry-run=client -o yaml | kubectl apply -f -\n\n# Restart services\nkubectl rollout restart deployment lifecycle-web lifecycle-worker -n lifecycle-app\n```\n\n---\n\n## Verify Webhook Delivery\n\n\n### Open Recent Deliveries\n\nGitHub App Settings > Advanced > Recent Deliveries\n\n### Interpret Status Icons\n\n| Icon | Meaning |\n|------|---------|\n| Green checkmark | Success (HTTP 200) |\n| Red X | Failed delivery |\n| Yellow warning | Timeout or partial failure |\n\n### Inspect Failed Deliveries\n\nClick any delivery to view:\n- Request headers (event type, `x-github-delivery` ID)\n- Request payload (event data)\n- Response (status code, error message)\n\n\nSave the `x-github-delivery` ID to search Lifecycle logs.\n\n\n### Redeliver After Fixing\n\nClick **Redeliver** to retry failed webhooks after resolving configuration issues.\n\n\n---\n\n## Debug Checklist\n\n```bash\n# 1. Check if app is installed\n# Repository Settings > Integrations > GitHub Apps\n\n# 2. Verify pods are running\nkubectl get pods -n lifecycle-app\n\n# 3. Check required secrets exist\nkubectl get secret app-secrets --namespace lifecycle-app \\\n  -o jsonpath=\'{.data}\' | jq \'keys\'\n\n# 4. Search logs for delivery ID\nkubectl logs -n lifecycle-app -l app=lifecycle-web --since=1h | grep "DELIVERY_ID"\n\n# 5. Check worker processing\nkubectl logs -n lifecycle-app -l app=lifecycle-worker --since=1h\n\n# 6. Verify Redis connectivity\nkubectl exec -it -n lifecycle-app deployment/lifecycle-web -- redis-cli ping\n\n# 7. Restart services if needed\nkubectl rollout restart deployment lifecycle-web lifecycle-worker -n lifecycle-app\n```\n\n### Required Kubernetes Secrets\n\n| Secret | Purpose |\n|--------|---------|\n| `GITHUB_APP_ID` | App identification |\n| `GITHUB_APP_PRIVATE_KEY` | Authentication |\n| `GITHUB_CLIENT_ID` | OAuth client |\n| `GITHUB_CLIENT_SECRET` | OAuth authentication |\n| `GITHUB_WEBHOOK_SECRET` | Webhook signature verification |\n\n### Log Messages to Look For\n\n| Message | Meaning |\n|---------|---------|\n| `Webhook: received event=...` | Event received successfully |\n| `Webhook: queued` | Event queued for processing |\n| `Webhook not verified` | Secret mismatch - sync secrets |\n\n---\n\n## Getting Help\n\nWhen reporting issues, include:\n\n1. `x-github-delivery` ID from failed webhook\n2. Lifecycle web and worker logs\n3. Screenshot of Recent Deliveries page\n4. Pod status output (`kubectl get pods -n lifecycle-app`)\n\nSee [Lifecycle GitHub repository](https://github.com/GoodRxOSS/lifecycle) for known issues.',
  },
  {
    title: "Build Issues",
    description:
      "Diagnose and resolve common build issues in Lifecycle environments",
    date: "2025-01-29",
    path: "docs/troubleshooting/build-issues",
    body: '## Quick Reference\n\n| Error Type | First Check | Quick Fix |\n|------------|-------------|-----------|\n| `config_error` | YAML syntax | Run `yamllint lifecycle.yaml` |\n| `build_failed` | Dockerfile path | Verify `dockerfilePath` exists |\n| Registry push failed | Credentials | Check IAM/service account permissions |\n| Service stuck on `waiting` | Dependencies | Check `dependsOn` services status |\n| OOMKilled | Memory limits | Increase pod memory or use Buildkit |\n\n---\n\n## Build Status Flow\n\n queued --> building --> built --> deploying --> deployed\n    building --> error["error / build_failed / config_error"]\n`} />\n\n| Status | Description |\n|--------|-------------|\n| `pending` | Waiting to be processed |\n| `queued` | Queued for processing |\n| `building` | Container images being built |\n| `built` | Images successfully built |\n| `deploying` | Services being deployed |\n| `deployed` | Environment fully deployed |\n| `error` | Error during build or deployment |\n| `config_error` | Invalid lifecycle.yaml |\n\n---\n\n## Configuration Errors\n\n**Symptom:** Status shows `config_error`, PR comment displays "Configuration Error"\n\n### YAML Syntax\n\n\n\n```yaml\n# Missing colon after services\nservices\n  - name: my-service\n\n# Bad indentation\nservices:\n- name: my-service\n    github:\n      repository: org/repo\n```\n\n\n```yaml\nservices:\n  - name: my-service\n    github:\n      repository: org/repo\n      branchName: main\n```\n\n\n\n**Fix:** Run `yamllint lifecycle.yaml` to catch syntax errors.\n\n### Missing Required Fields\n\n\n\n```yaml\nversion: "1.0.0"\nservices:\n  - name: my-service\n    # Missing github.repository\n```\n\n\n```yaml\nversion: "1.0.0"\nservices:\n  - name: my-service\n    github:\n      repository: org/repo\n      branchName: main\n```\n\n\n\n**Fix:** Review your configuration against the [schema reference](/docs/schema).\n\n---\n\n## Dockerfile Issues\n\n### Missing Dockerfile\n\n**Error:** `Git: SHA fetch failed` or empty build output\n\n\n\n```yaml\nservices:\n  - name: my-service\n    github:\n      docker:\n        app:\n          dockerfilePath: ./docker/Dockerfile  # File doesn\'t exist\n```\n\n\n```yaml\nservices:\n  - name: my-service\n    github:\n      docker:\n        app:\n          dockerfilePath: ./Dockerfile  # Verified to exist in repo\n```\n\n\n\n**Checklist:**\n- [ ] File exists at specified path\n- [ ] File is committed to the branch\n- [ ] Path is relative to repository root\n\n### Build Context Errors\n\n**Error:** `COPY failed` or `file not found`\n\n| Problem | Solution |\n|---------|----------|\n| File not in context | Ensure files are relative to build context |\n| File excluded | Check `.dockerignore` isn\'t excluding required files |\n| Wrong path | Use paths relative to Dockerfile location |\n\n---\n\n## Registry Issues\n\n### ECR Authentication\n\n**Error:** `AWS credentials not configured`\n\n| Check | Command/Action |\n|-------|----------------|\n| Service account permissions | Verify IAM role has ECR push access |\n| Repository exists | `aws ecr describe-repositories` |\n| Region configured | Check cluster configuration |\n\n### Push Failures\n\n**Error:** `failed to push` or timeout\n\n| Cause | Solution |\n|-------|----------|\n| Network issue | Check registry accessibility from cluster |\n| Invalid tag | Verify image tag format |\n| Rate limiting | Wait and retry, or use private registry |\n\n---\n\n## Build Engine Issues\n\n\n\n\n### Buildkit\n\n**Connection Errors**\n\nError: `failed to solve` or connection timeout\n\n| Cause | Fix |\n|-------|-----|\n| Service not running | Verify Buildkit service status |\n| Network blocked | Check network policies |\n| Bad endpoint | Verify `BUILDKIT_HOST` env var |\n\n**Cache Issues**\n\nError: Slow builds or cache import failures\n\n| Cause | Fix |\n|-------|-----|\n| Cache inaccessible | Verify cache registry is reachable |\n| Stale cache | Force rebuild by updating Dockerfile |\n\n\n\n\n### Kaniko\n\n**Docker Config Issues**\n\nError: `error checking push permissions`\n\n| Cause | Fix |\n|-------|-----|\n| Config not mounted | Verify registry login init container completed |\n| Missing credentials | Check Docker config generation |\n| Permission denied | Ensure service account has required permissions |\n\n**Memory Issues**\n\nError: Build pod `OOMKilled` or hangs\n\n| Cause | Fix |\n|-------|-----|\n| Large image layers | Increase memory limits |\n| Inefficient Dockerfile | Optimize with multi-stage builds |\n| Persistent issues | Consider switching to Buildkit |\n\n\n\n\n---\n\n## Accessing Build Logs\n\n### Quick Access Methods\n\n| Method | Steps |\n|--------|-------|\n| GitHub PR | Click build logs link in Lifecycle comment |\n| Dashboard | Navigate to environment → Click service → View logs |\n| kubectl | See commands below |\n\n### kubectl Commands\n\n```bash\n# List build jobs\nkubectl get jobs -n env- -l app.kubernetes.io/component=build\n\n# View build logs\nkubectl logs -n env- job/\n\n# View init container logs (git clone step)\nkubectl logs -n env- job/ -c git-clone\n```\n\n---\n\n## Dependency Issues\n\n### Service Stuck on `waiting`\n\n**Checklist:**\n- [ ] Dependent service status is not `error` or `build_failed`\n- [ ] No circular dependencies in `dependsOn`\n- [ ] Dependent service exists in configuration\n\n### Environment Variable Resolution Failed\n\n**Error:** Missing values from dependent builds\n\n| Check | Action |\n|-------|--------|\n| Extraction pattern | Verify regex matches build output |\n| Dependency output | Review build logs of dependency |\n| Order of operations | Ensure dependency builds first |\n\n---\n\n## Troubleshooting Steps\n\n\n### Check PR Comment\n\nReview the Lifecycle comment for status and error messages.\n\n### Validate Configuration\n\n```bash\nyamllint lifecycle.yaml\n```\n\n### Review Build Logs\n\nAccess logs via GitHub, Dashboard, or kubectl.\n\n### Check Dependencies\n\nVerify all `dependsOn` services completed successfully.\n\n### Retry Build\n\nPush a new commit or remove/re-add the lifecycle label.\n\n\n---\n\n## Common Errors Reference\n\n| Error | Cause | Fix |\n|-------|-------|-----|\n| `Config file is empty` | No content in lifecycle.yaml | Add valid configuration |\n| `Build not found` | Build record missing | Re-trigger the build |\n| `Git: SHA fetch failed` | Branch not found | Verify branch name and access |\n| `ECR: config missing` | Registry config incomplete | Check global configuration |\n| `Unsupported builder engine` | Invalid engine | Use `buildkit` or `kaniko` |\n| `Namespace did not become ready` | K8s creation timeout | Check cluster resources |\n\n---\n\n## Getting Help\n\nInclude when reporting issues:\n\n- Build UUID\n- Service name\n- Error messages from logs\n- Steps to reproduce\n\nSee [Lifecycle GitHub repository](https://github.com/GoodRxOSS/lifecycle) for known issues.',
  },
  {
    title: "Webhooks Configuration",
    description:
      "Configure webhooks to run automated tasks when environment events occur",
    date: "2025-01-29",
    path: "docs/schema/webhooks",
    body: 'Webhooks allow you to trigger automated tasks when specific events occur in your Lifecycle environment. You can use webhooks to send notifications, run tests, or perform cleanup tasks.\n\n## Overview\n\nWebhooks are configured in the `environment.webhooks` array of your `lifecycle.yaml` file. When a specified event occurs (like deployment completing), Lifecycle executes your webhook.\n\n```yaml filename="lifecycle.yaml"\nenvironment:\n  webhooks:\n    - name: "notify-slack"\n      state: "deployed"\n      type: "docker"\n      docker:\n        image: "curlimages/curl:latest"\n        command: ["curl", "-X", "POST", "https://hooks.slack.com/..."]\n      env:\n        WEBHOOK_URL: "https://hooks.slack.com/services/..."\n```\n\n---\n\n## Webhook Fields Reference\n\n### Required Fields\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `state` | string | **Required.** When the webhook fires. One of: `deployed`, `error`, `torn_down` |\n| `type` | string | **Required.** How the webhook runs. One of: `docker`, `command`, `codefresh` |\n| `env` | object | **Required.** Environment variables passed to the webhook |\n\n### Optional Fields\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `name` | string | Identifier for logging and debugging |\n| `description` | string | Human-readable description of what the webhook does |\n\n---\n\n## Webhook States (Triggers)\n\nThe `state` field determines when your webhook fires:\n\n| State | When It Fires |\n|-------|---------------|\n| `deployed` | After all services in the environment are successfully deployed |\n| `error` | When a build or deployment fails |\n| `torn_down` | After the environment is cleaned up (PR closed or manually torn down) |\n\n---\n\n## Webhook Types\n\n### Docker Webhooks\n\nRun a Docker container to execute your webhook logic. Best for complex tasks or when you need specific tools.\n\n```yaml\nwebhooks:\n  - name: "integration-tests"\n    state: "deployed"\n    type: "docker"\n    docker:\n      image: "myorg/test-runner:latest"\n      command: ["npm", "run", "test:integration"]\n      args: ["--env", "lifecycle"]\n      timeout: 3600\n    env:\n      API_URL: "{{myservice_publicUrl}}"\n      TEST_ENV: "lifecycle"\n```\n\n**Docker Configuration Fields:**\n\n| Field | Type | Required | Default | Description |\n|-------|------|----------|---------|-------------|\n| `docker.image` | string | Yes | - | Docker image to run |\n| `docker.command` | array | No | - | Command to execute (overrides image entrypoint) |\n| `docker.args` | array | No | - | Arguments passed to the command |\n| `docker.timeout` | number | No | 1800 | Maximum execution time in seconds (1-86400) |\n\n### Command Webhooks\n\nRun a shell script inside a container. Best for simple tasks that can be expressed as a script.\n\n```yaml\nwebhooks:\n  - name: "notify-team"\n    state: "deployed"\n    type: "command"\n    command:\n      image: "curlimages/curl:latest"\n      script: |\n        curl -X POST "$SLACK_WEBHOOK_URL" \\\n          -H "Content-Type: application/json" \\\n          -d \'{"text": "Environment deployed: \'"$BUILD_URL"\'"}\'\n      timeout: 300\n    env:\n      SLACK_WEBHOOK_URL: "https://hooks.slack.com/services/..."\n      BUILD_URL: "{{build_publicUrl}}"\n```\n\n**Command Configuration Fields:**\n\n| Field | Type | Required | Default | Description |\n|-------|------|----------|---------|-------------|\n| `command.image` | string | Yes | - | Container image to run the script in |\n| `command.script` | string | Yes | - | Shell script to execute |\n| `command.timeout` | number | No | 1800 | Maximum execution time in seconds (1-86400) |\n\n### Codefresh Webhooks\n\nTrigger a Codefresh pipeline. Best when you have existing CI/CD pipelines in Codefresh.\n\n```yaml\nwebhooks:\n  - name: "run-e2e-tests"\n    state: "deployed"\n    type: "codefresh"\n    pipelineId: "my-project/e2e-tests"\n    trigger: "lifecycle-deploy"\n    env:\n      ENVIRONMENT_URL: "{{myapp_publicUrl}}"\n```\n\n**Codefresh Configuration Fields:**\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `pipelineId` | string | Yes | The Codefresh pipeline ID to trigger |\n| `trigger` | string | Yes | The Codefresh trigger name to use |\n\n---\n\n## Environment Variables\n\nThe `env` field passes environment variables to your webhook. You can use template variables to include dynamic values:\n\n```yaml\nenv:\n  # Static values\n  SLACK_CHANNEL: "#deployments"\n\n  # Template variables (resolved at execution time)\n  SERVICE_URL: "{{myservice_publicUrl}}"\n  BUILD_UUID: "{{build_uuid}}"\n  NAMESPACE: "{{build_namespace}}"\n```\n\n\nSee [Template Variables](/docs/features/template-variables) for the full list of available variables.\n\n\n---\n\n## Timeout Configuration\n\n- **Default timeout:** 1800 seconds (30 minutes)\n- **Minimum timeout:** 1 second\n- **Maximum timeout:** 86400 seconds (24 hours)\n\nIf a webhook exceeds its timeout, it will be terminated.\n\n---\n\n## Practical Examples\n\n### Slack Notification on Deploy\n\n```yaml\nwebhooks:\n  - name: "slack-deploy-notification"\n    description: "Notify team when environment is ready"\n    state: "deployed"\n    type: "command"\n    command:\n      image: "curlimages/curl:8.1.0"\n      script: |\n        curl -X POST "$SLACK_WEBHOOK" \\\n          -H "Content-Type: application/json" \\\n          -d \'{\n            "text": "Environment Ready!",\n            "blocks": [\n              {\n                "type": "section",\n                "text": {\n                  "type": "mrkdwn",\n                  "text": "*Environment deployed successfully*\\nURL: \'"$APP_URL"\'"\n                }\n              }\n            ]\n          }\'\n    env:\n      SLACK_WEBHOOK: "https://hooks.slack.com/services/T00/B00/XXX"\n      APP_URL: "{{myapp_publicUrl}}"\n```\n\n### Run Integration Tests After Deploy\n\n```yaml\nwebhooks:\n  - name: "integration-tests"\n    description: "Run integration test suite"\n    state: "deployed"\n    type: "docker"\n    docker:\n      image: "myorg/test-runner:v2"\n      command: ["npm", "run", "test:integration"]\n      timeout: 3600\n    env:\n      API_BASE_URL: "{{api_publicUrl}}"\n      AUTH_SERVICE_URL: "{{auth_internalHostname}}"\n      TEST_TIMEOUT: "60000"\n```\n\n### Cleanup Tasks on Teardown\n\n```yaml\nwebhooks:\n  - name: "cleanup-external-resources"\n    description: "Clean up test data in external systems"\n    state: "torn_down"\n    type: "docker"\n    docker:\n      image: "myorg/cleanup-tool:latest"\n      command: ["./cleanup.sh"]\n      timeout: 600\n    env:\n      ENVIRONMENT_ID: "{{build_uuid}}"\n      CLEANUP_DATABASE: "true"\n```\n\n### Error Notification\n\n```yaml\nwebhooks:\n  - name: "error-alert"\n    description: "Alert on-call when deployment fails"\n    state: "error"\n    type: "command"\n    command:\n      image: "curlimages/curl:8.1.0"\n      script: |\n        curl -X POST "$PAGERDUTY_URL" \\\n          -H "Content-Type: application/json" \\\n          -d \'{"event_action": "trigger", "payload": {"summary": "Lifecycle deployment failed", "source": "lifecycle"}}\'\n    env:\n      PAGERDUTY_URL: "https://events.pagerduty.com/v2/enqueue"\n```\n\n### Multiple Webhooks\n\nYou can configure multiple webhooks for different events:\n\n```yaml\nenvironment:\n  webhooks:\n    # Notify on successful deploy\n    - name: "deploy-success"\n      state: "deployed"\n      type: "command"\n      command:\n        image: "curlimages/curl:latest"\n        script: \'curl -X POST "$WEBHOOK_URL" -d "status=deployed"\'\n      env:\n        WEBHOOK_URL: "https://example.com/webhook"\n\n    # Run tests after deploy\n    - name: "smoke-tests"\n      state: "deployed"\n      type: "docker"\n      docker:\n        image: "myorg/smoke-tests:latest"\n        timeout: 600\n      env:\n        TARGET_URL: "{{myapp_publicUrl}}"\n\n    # Alert on errors\n    - name: "error-notification"\n      state: "error"\n      type: "command"\n      command:\n        image: "curlimages/curl:latest"\n        script: \'curl -X POST "$WEBHOOK_URL" -d "status=error"\'\n      env:\n        WEBHOOK_URL: "https://example.com/webhook"\n\n    # Cleanup on teardown\n    - name: "cleanup"\n      state: "torn_down"\n      type: "docker"\n      docker:\n        image: "myorg/cleanup:latest"\n      env:\n        ENV_ID: "{{build_uuid}}"\n```\n\n---\n\n## Troubleshooting\n\n### Webhook Not Firing\n\n1. Verify the `state` matches the event you expect\n2. Check that both `type` and `state` are specified (both are required)\n3. Ensure the `env` field is present (even if empty: `env: {}`)\n\n### Webhook Timing Out\n\n1. Check if your task needs more time and increase the `timeout` value\n2. For long-running tasks, consider using asynchronous patterns (trigger a job and exit)\n\n### Docker Image Not Found\n\n1. Verify the image name and tag are correct\n2. Ensure the image is accessible from your Kubernetes cluster\n3. For private registries, ensure proper authentication is configured\n\n### Environment Variables Not Available\n\n1. Verify the variable names in your `env` block\n2. Check that template variables use the correct syntax: `{{variable_name}}`\n3. Ensure referenced services exist in your environment',
  },
  {
    title: "Helm Services",
    description:
      "Complete schema documentation for helm-type services in Lifecycle, including native helm deployments, chart configuration, and environment variable mapping.",
    date: "2025-01-17",
    path: "docs/schema/helm-services",
    body: '## Quick Reference\n\n| Field | Required | Description |\n|-------|----------|-------------|\n| `helm.deploymentMethod` | No | `"native"` (recommended) or `"ci"` |\n| `helm.version` | Yes* | Helm CLI version (e.g., `"3.12.0"`) |\n| `helm.chart.name` | Yes | Chart name, path (`./charts/app`), or `"local"` |\n| `helm.chart.repoUrl` | For public | Repository URL (e.g., Bitnami) |\n| `helm.chart.version` | Recommended | Chart version for reproducibility |\n| `helm.chart.values` | No | Array of `"key=value"` overrides |\n| `helm.chart.valueFiles` | No | Array of value file paths |\n| `helm.repository` | For local/files | GitHub repo (`"org/repo"`) |\n| `helm.branchName` | With repository | Branch to clone |\n| `helm.envMapping` | For local | How to pass env vars to chart |\n| `helm.docker` | For custom images | Docker build configuration |\n\n\nHelm services do **not** use the `deployment` block. All resources, probes, and networking are configured through `chart.values` and `chart.valueFiles`.\n\n\n---\n\n## Chart Types at a Glance\n\n\n\n| Use Case | Chart Type | Key Requirements |\n|----------|------------|------------------|\n| Third-party databases (PostgreSQL, Redis) | Public | `repoUrl`, `chart.version` |\n| Custom app in your repo | Local | `repository`, `branchName`, chart path |\n| Org standard chart + custom Docker image | Org | `docker.app.dockerfilePath` |\n| Public chart + custom value files | Public | `repository`, `branchName`, `valueFiles` |\n\n---\n\n## Common Patterns\n\n### Public Chart (PostgreSQL)\n\n```yaml filename="lifecycle.yaml"\nservices:\n  - name: "postgres-db"\n    appShort: "pgdb"\n    helm:\n      deploymentMethod: "native"\n      version: "3.12.0"\n      chart:\n        name: "postgresql"\n        repoUrl: "https://charts.bitnami.com/bitnami"\n        version: "12.9.0"\n        values:\n          - "auth.username=lifecycle_user"\n          - "auth.password=secretpassword"\n          - "auth.database=lifecycle_db"\n          - "persistence.enabled=true"\n          - "persistence.size=10Gi"\n```\n\n### Local Chart with Docker Build\n\n```yaml filename="lifecycle.yaml"\nservices:\n  - name: "my-application"\n    appShort: "myapp"\n    helm:\n      deploymentMethod: "native"\n      version: "3.14.0"\n      repository: "my-org/my-repo"\n      branchName: "main"\n      args: "--atomic --wait --timeout 30m"\n      chart:\n        name: "./charts/my-app"\n        values:\n          - "replicaCount=2"\n      envMapping:\n        app:\n          format: "array"\n          path: "deployment.env"\n      docker:\n        defaultTag: "latest"\n        app:\n          dockerfilePath: "Dockerfile"\n          env:\n            NODE_ENV: "production"\n          ports:\n            - "3000"\n```\n\n---\n\n## Common Mistakes\n\n### Wrong: `envMapping` inside `chart`\n\n```yaml\n# WRONG - envMapping will be ignored\nservices:\n  - name: "my-app"\n    helm:\n      chart:\n        name: "./charts/my-app"\n        envMapping:  # Wrong location!\n          app:\n            format: "array"\n            path: "deployment.env"\n```\n\n### Correct: `envMapping` under `helm`\n\n```yaml\n# CORRECT - envMapping at helm level\nservices:\n  - name: "my-app"\n    helm:\n      chart:\n        name: "./charts/my-app"\n      envMapping:  # Correct location\n        app:\n          format: "array"\n          path: "deployment.env"\n```\n\n### Wrong: Missing `repository` for value files\n\n```yaml\n# WRONG - valueFiles won\'t be found\nservices:\n  - name: "redis"\n    helm:\n      chart:\n        name: "redis"\n        repoUrl: "https://charts.bitnami.com/bitnami"\n        valueFiles:\n          - "helm/values/redis.yaml"  # Where is this file?\n```\n\n### Correct: Include `repository` and `branchName`\n\n```yaml\n# CORRECT - repository specified for valueFiles\nservices:\n  - name: "redis"\n    helm:\n      repository: "my-org/my-repo"\n      branchName: "main"\n      chart:\n        name: "redis"\n        repoUrl: "https://charts.bitnami.com/bitnami"\n        valueFiles:\n          - "helm/values/redis.yaml"\n```\n\n### Wrong: `envMapping` with public chart\n\n```yaml\n# WRONG - envMapping only works with local charts\nservices:\n  - name: "postgres"\n    helm:\n      chart:\n        name: "postgresql"\n        repoUrl: "https://charts.bitnami.com/bitnami"\n      envMapping:  # Ignored for public charts!\n        app:\n          format: "array"\n          path: "env"\n```\n\n---\n\n## Schema Reference\n\n### Deployment Configuration\n\n#### `deploymentMethod`\n\n| Property | Value |\n|----------|-------|\n| **Type** | `string` |\n| **Default** | Determined by `nativeHelm.enabled` or falls back to CI |\n| **Values** | `"native"` or `"ci"` |\n\n- **`native`**: Runs in Kubernetes jobs within the ephemeral namespace. Provides real-time deploy logs in the UI.\n- **`ci`**: Legacy method using external CI/CD (e.g., Codefresh).\n\n#### `version`\n\n| Property | Value |\n|----------|-------|\n| **Type** | `string` |\n| **Required** | Yes (for native deployment) |\n| **Default** | `"3.12.0"` (from global config) |\n\nSpecifies the Helm CLI version (must match `alpine/helm` Docker image tags).\n\n\nMissing version causes: "Helm version is required" error.\n\n\n#### `args`\n\n| Property | Value |\n|----------|-------|\n| **Type** | `string` |\n| **Default** | None (global `defaultArgs` may apply) |\n\nCommon arguments:\n- `--wait` - Wait for resources to be ready\n- `--timeout 30m` - Set deployment timeout\n- `--atomic` - Roll back on failure\n- `--force` - Force resource updates\n\nService-level `args` take precedence over global `defaultArgs` for conflicting flags.\n\n#### `repository` and `branchName`\n\n| Property | Type | Required |\n|----------|------|----------|\n| `repository` | `string` (`"org/repo"`) | When using local charts or valueFiles |\n| `branchName` | `string` | When `repository` is specified |\n\n---\n\n### Chart Configuration\n\n#### `chart.name`\n\nDetermines the chart type based on format:\n\n| Format | Type | Example |\n|--------|------|---------|\n| Simple name | Public | `"postgresql"`, `"redis"` |\n| Path starting with `./` or `../` | Local | `"./charts/my-app"` |\n| `"local"` | Local | `"local"` |\n| Org chart name + `docker` config | Org | `"org-chart"` |\n\n#### `chart.repoUrl`\n\nRequired for public charts. Supports:\n\n- **Standard repos**: `https://charts.bitnami.com/bitnami`\n- **OCI registries**: `oci://registry.example.com/charts`\n\nBuilt-in aliases: `bitnami`, `stable`, `prometheus-community`, `grafana`\n\n#### `chart.version`\n\n\nAlways specify versions in production for reproducible deployments. Without a version, Helm uses latest.\n\n\n#### `chart.values`\n\nArray of `"key=value"` strings passed via `--set` flags.\n\n| Syntax | Example |\n|--------|---------|\n| Simple | `"replicas=3"` |\n| Nested (dot notation) | `"auth.username=admin"` |\n| Arrays (brackets) | `"tolerations[0].key=dedicated"` |\n| Template variables | `"buildId={{build.uuid}}"` |\n\n#### `chart.valueFiles`\n\nArray of file paths relative to repository root. Applied in order (later files override earlier).\n\n\nService-level `valueFiles` **completely replace** global defaults (no merging).\n\n\n---\n\n### Environment Variable Mapping\n\n\n`envMapping` only works with **LOCAL** chart types (paths starting with `./` or `../`).\n\n\n#### `envMapping.app` and `envMapping.init`\n\n| Property | Type | Required |\n|----------|------|----------|\n| `format` | `"array"` or `"map"` | Yes |\n| `path` | `string` | Yes |\n\n**Array format** (for Kubernetes env spec):\n```yaml\nenvMapping:\n  app:\n    format: "array"\n    path: "deployment.env"\n# Generates:\n# deployment.env[0].name=MY_VAR\n# deployment.env[0].value=my-value\n```\n\n**Map format** (flat key-value):\n```yaml\nenvMapping:\n  app:\n    format: "map"\n    path: "env"\n# Generates:\n# env.MY__VAR=my-value  (underscores escaped as __)\n```\n\n---\n\n### Docker Configuration\n\nRequired for org charts; optional for local charts.\n\n#### `docker.app` (required when using `docker`)\n\n| Property | Type | Required | Description |\n|----------|------|----------|-------------|\n| `dockerfilePath` | `string` | Yes | Path relative to repo root |\n| `command` | `string` | No | Override Dockerfile CMD |\n| `arguments` | `string` | No | Args separated by `%%SPLIT%%` |\n| `env` | `object` | No | Environment variables |\n| `ports` | `string[]` | No | Exposed ports |\n\n#### `docker.init` (optional)\n\nSame structure as `docker.app` for init containers (database migrations, setup tasks).\n\n#### `docker.builder.engine`\n\n| Value | Description |\n|-------|-------------|\n| `"buildkit"` | Faster builds with advanced caching |\n| `"kaniko"` | No privileged access required |\n\n---\n\n### Additional Options\n\n| Option | Type | Default | Description |\n|--------|------|---------|-------------|\n| `type` | `string` | `"deployment"` | Resource type: `deployment`, `statefulset`, `daemonset` |\n| `grpc` | `boolean` | `false` | Configure ingress for gRPC traffic |\n| `disableIngressHost` | `boolean` | `false` | No external ingress (internal services) |\n| `envLens` | `boolean` | `false` | Inject environment identification banner |\n\n---\n\n## Configuration Precedence\n\nValues merge from lowest to highest priority:\n\n B["2. Chart-specific global config\\nPer-chart defaults"]\n    B --> C["1. Global helmDefaults (lowest priority)\\nOrganization defaults"]\n`} />\n\n**Merging behavior:**\n- `values` arrays: Merged (service overrides duplicates)\n- `valueFiles` arrays: **Not merged** (service replaces entirely)\n- Scalar values (`version`, `args`): Overridden entirely\n\n---\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| "Helm version is required" | Add `helm.version: "3.12.0"` |\n| Value files not found | Add `repository` and `branchName` |\n| Env vars not passed to pods | Move `envMapping` under `helm`, not `chart` |\n| Env vars ignored | `envMapping` only works with local charts |\n| Chart not found | Verify `repoUrl` for public charts or path for local |\n| Deployment timeout | Add `args: "--timeout 30m"` |\n\n---\n\n## Complete Examples\n\n### Public Chart with Custom Value Files\n\n```yaml filename="lifecycle.yaml"\nservices:\n  - name: "redis-cache"\n    appShort: "redis"\n    helm:\n      deploymentMethod: "native"\n      version: "3.12.0"\n      repository: "my-org/my-repo"\n      branchName: "main"\n      chart:\n        name: "redis"\n        repoUrl: "https://charts.bitnami.com/bitnami"\n        version: "17.11.3"\n        valueFiles:\n          - "helm/values/redis-base.yaml"\n          - "helm/values/redis-lifecycle.yaml"\n```\n\n### Organization Chart with Init Container\n\n```yaml filename="lifecycle.yaml"\nservices:\n  - name: "my-service"\n    appShort: "mysvc"\n    helm:\n      deploymentMethod: "native"\n      version: "3.12.0"\n      repository: "my-org/my-service"\n      branchName: "main"\n      type: "deployment"\n      envLens: true\n      chart:\n        name: "org-chart"\n        values:\n          - "deployment.replicas=3"\n      docker:\n        defaultTag: "latest"\n        app:\n          dockerfilePath: "Dockerfile"\n          command: "python"\n          arguments: "-m%%SPLIT%%uvicorn%%SPLIT%%main:app%%SPLIT%%--host%%SPLIT%%0.0.0.0"\n          env:\n            DATABASE_URL: "postgres://db:5432/app"\n          ports:\n            - "8000"\n        init:\n          dockerfilePath: "Dockerfile.migrations"\n          command: "python"\n          arguments: "manage.py%%SPLIT%%migrate"\n          env:\n            DATABASE_URL: "postgres://db:5432/app"\n```\n\n---\n\n## When to Use What\n\n| Scenario | Configuration |\n|----------|---------------|\n| Deploy PostgreSQL/Redis/etc. | Public chart with `repoUrl` |\n| Custom app with your own chart | Local chart (`./charts/...`) + `repository` |\n| Org standard deployment | Org chart + `docker` config |\n| Need custom values for public chart | Add `repository` + `valueFiles` |\n| Pass env vars to local chart | Use `envMapping` with `format` and `path` |\n| Internal service (no ingress) | Set `disableIngressHost: true` |\n| gRPC service | Set `grpc: true` |\n| Database with persistent storage | `type: "statefulset"` |',
  },
  {
    title: "Lifecycle Full Schema",
    description:
      "Complete annotated schema reference for lifecycle.yaml with all configuration options, defaults, and descriptions.",
    date: "2025-01-17",
    path: "docs/schema/full",
    body: '## Full Lifecycle Schema\n\nBelow is the complete `lifecycle.yaml` schema with detailed comments explaining each field, its type, whether it\'s required, and default values.\n\n\nThis is a comprehensive reference. For topic-specific documentation, see the individual schema pages for [Environment](/docs/schema/environment), [Docker Services](/docs/schema/docker-services), [GitHub Services](/docs/schema/github-services), and [Helm Services](/docs/schema/helm-services).\n\n\n```yaml\n# ============================================================================\n# LIFECYCLE SCHEMA v1.0.0\n# Complete configuration reference for lifecycle.yaml\n# ============================================================================\n\n# Schema version (required)\n# Type: string\n# Valid values: "1.0.0"\nversion: "1.0.0"\n\n# ============================================================================\n# ENVIRONMENT CONFIGURATION\n# Controls global deployment behavior and service selection\n# ============================================================================\nenvironment:\n  # Automatically deploy when a PR is opened or reopened\n  # Type: boolean | Required: No | Default: false\n  # When true: environments deploy immediately when PRs are opened\n  # When false: must manually add lifecycle-deploy! label\n  autoDeploy: false\n\n  # Create GitHub Deployments for tracking in GitHub UI\n  # Type: boolean | Required: No | Default: false\n  # Enables deployment status in PR timeline and Environments page\n  githubDeployments: false\n\n  # Post status comments on pull requests\n  # Type: boolean | Required: No | Default: false\n  # Includes deployment progress, service URLs, and checkboxes\n  # Can also enable per-PR with lifecycle-status-comments! label\n  useGithubStatusComment: false\n\n  # Feature flags to enable special behaviors\n  # Type: array of strings | Required: No | Default: []\n  # Available flags:\n  #   - "no-default-env-resolve": Prevents resolution to default UUIDs\n  #   - "hack-force-pull-request-branch": Forces services to use PR branch\n  #   - "hack-force-pull-request-service-": Per-service PR branch hack\n  enabledFeatures:\n    - "no-default-env-resolve"\n\n  # Services that always deploy with the environment\n  # Type: array | Required: No\n  defaultServices:\n    - # Service name (must match a defined service)\n      # Type: string | Required: Yes\n      name: ""\n      # GitHub repository for external services (org/repo format)\n      # Type: string | Required: No (only for external services)\n      repository: ""\n      # Branch for external services\n      # Type: string | Required: No (only for external services)\n      branch: ""\n\n  # Services that can be optionally enabled through PR interface\n  # Type: array | Required: No\n  optionalServices:\n    - # Same structure as defaultServices\n      name: ""\n      repository: ""\n      branch: ""\n\n  # Webhooks for custom automation on deployment events\n  # Type: array | Required: No\n  webhooks:\n    - # Webhook identifier for logging\n      # Type: string | Required: No\n      name: ""\n\n      # Human-readable description\n      # Type: string | Required: No\n      description: ""\n\n      # When the webhook fires\n      # Type: string | Required: Yes\n      # Valid values: "deployed", "error", "torn_down"\n      state: "deployed"\n\n      # How the webhook executes\n      # Type: string | Required: Yes\n      # Valid values: "docker", "command", "codefresh"\n      type: "docker"\n\n      # Docker webhook configuration (when type: "docker")\n      docker:\n        # Docker image to run\n        # Type: string | Required: Yes\n        image: ""\n        # Command to execute (overrides entrypoint)\n        # Type: array | Required: No\n        command: []\n        # Arguments passed to command\n        # Type: array | Required: No\n        args: []\n        # Maximum execution time in seconds\n        # Type: number | Required: No | Default: 1800\n        # Min: 1, Max: 86400 (24 hours)\n        timeout: 1800\n\n      # Command webhook configuration (when type: "command")\n      command:\n        # Container image to run script in\n        # Type: string | Required: Yes\n        image: ""\n        # Shell script to execute\n        # Type: string | Required: Yes\n        script: ""\n        # Maximum execution time in seconds\n        # Type: number | Required: No | Default: 1800\n        timeout: 1800\n\n      # Codefresh webhook configuration (when type: "codefresh")\n      # Type: string | Required: Yes (for codefresh type)\n      pipelineId: ""\n      # Type: string | Required: Yes (for codefresh type)\n      trigger: ""\n\n      # Environment variables passed to the webhook\n      # Type: object | Required: Yes\n      # Supports template variables: {{service_publicUrl}}, {{build_uuid}}\n      env: {}\n\n# ============================================================================\n# SERVICES CONFIGURATION\n# Define individual services in your environment\n# ============================================================================\nservices:\n  # --------------------------------------------------------------------------\n  # GITHUB SERVICE TYPE\n  # Build and deploy from GitHub source code\n  # --------------------------------------------------------------------------\n  - # Unique service identifier\n    # Type: string | Required: Yes\n    name: ""\n\n    # Short identifier for registry organization\n    # Type: string | Required: No\n    # Used for image path: {registry}/{appShort}/lfc\n    appShort: ""\n\n    # Fallback UUID for inactive services\n    # Type: string | Required: No\n    defaultUUID: ""\n\n    # Services that must be included when this service deploys\n    # Type: array | Required: No\n    requires:\n      - name: ""\n\n    # Services that must deploy before this one\n    # Type: array of strings | Required: No\n    # Only affects order, doesn\'t auto-include services\n    deploymentDependsOn:\n      - ""\n\n    # GitHub-specific configuration\n    github:\n      # GitHub repository (org/repo format)\n      # Type: string | Required: Yes\n      repository: ""\n\n      # Branch to build from\n      # Type: string | Required: Yes\n      branchName: ""\n\n      # Docker build configuration\n      docker:\n        # Default image tag when not building from commit\n        # Type: string | Required: Yes\n        defaultTag: ""\n\n        # External CI/CD pipeline ID (for Codefresh)\n        # Type: string | Required: No\n        pipelineId: ""\n\n        # Custom ECR repository URL\n        # Type: string | Required: No\n        ecr: ""\n\n        # Build engine configuration\n        builder:\n          # Build engine to use\n          # Type: string | Required: No\n          # Valid values: "buildkit", "kaniko"\n          # buildkit: Faster with better caching (recommended)\n          # kaniko: Builds without Docker daemon\n          engine: "buildkit"\n\n        # Main application container configuration\n        app:\n          # Path to Dockerfile (relative to repo root)\n          # Type: string | Required: Yes\n          dockerfilePath: ""\n\n          # Override container entrypoint\n          # Type: string | Required: No\n          command: ""\n\n          # Arguments passed to command\n          # Type: string | Required: No\n          # Use %%SPLIT%% delimiter for multiple args\n          arguments: ""\n\n          # Environment variables for the container\n          # Type: object | Required: No\n          # Supports template variables: {{service_internalHostname}}\n          env: {}\n\n          # Ports exposed by the container\n          # Type: array | Required: No | Default: ["8080"]\n          ports:\n            - "8080"\n\n          # Post-build pipeline configuration\n          afterBuildPipelineConfig:\n            # Pipeline ID to run after build\n            # Type: string | Required: No\n            afterBuildPipelineId: ""\n            # Run pipeline asynchronously\n            # Type: boolean | Required: No | Default: false\n            detatchAfterBuildPipeline: false\n            # Pipeline description\n            # Type: string | Required: No\n            description: ""\n\n        # Init container configuration (runs before main app)\n        init:\n          # Path to init container Dockerfile\n          # Type: string | Required: Yes (if using init)\n          dockerfilePath: ""\n          # Init container command\n          # Type: string | Required: No\n          command: ""\n          # Init container arguments\n          # Type: string | Required: No\n          arguments: ""\n          # Init container environment variables\n          # Type: object | Required: No\n          env: {}\n\n      # Deployment configuration\n      # NOTE: This entire block only applies to docker and github services\n      # Helm services configure deployment settings through chart values instead\n      deployment:\n        # Create Kubernetes Ingress for hostname access\n        # Type: boolean | Required: No | Default: false\n        # Applies to: docker and github services only (not helm)\n        # true: Lifecycle creates Ingress, service accessible via hostname\n        # false: No Ingress, service only accessible within cluster\n        # Note: For helm services, ingress is managed by the chart itself\n        public: false\n\n        # Compute capacity type\n        # Type: string | Required: No | Default: "SPOT"\n        # Valid values: "ON_DEMAND", "SPOT"\n        # ON_DEMAND: Standard instances (production, databases)\n        # SPOT: Cost-savings, may be interrupted (fault-tolerant workloads)\n        capacityType: "SPOT"\n\n        # CPU and memory resource allocation\n        resource:\n          cpu:\n            # Minimum CPU guaranteed\n            # Type: string | Required: No\n            # Format: "100m", "0.5", "2" (Kubernetes CPU units)\n            request: ""\n            # Maximum CPU allowed\n            # Type: string | Required: No\n            limit: ""\n          memory:\n            # Minimum memory guaranteed\n            # Type: string | Required: No\n            # Format: "128Mi", "512Mi", "1Gi", "2Gi"\n            request: ""\n            # Maximum memory allowed\n            # Type: string | Required: No\n            limit: ""\n\n        # Health check configuration\n        readiness:\n          # Disable readiness checks entirely\n          # Type: boolean | Required: No | Default: false\n          disabled: false\n\n          # TCP socket health check port\n          # Type: number | Required: No\n          # Use either tcpSocketPort OR httpGet, not both\n          tcpSocketPort: 0\n\n          # HTTP health check configuration\n          httpGet:\n            # Health check endpoint path\n            # Type: string | Required: No\n            path: ""\n            # Health check port\n            # Type: number | Required: No\n            port: 0\n\n          # Seconds before first health check\n          # Type: number | Required: No | Default: 0\n          initialDelaySeconds: 0\n\n          # Seconds between health checks\n          # Type: number | Required: No | Default: 10\n          periodSeconds: 10\n\n          # Seconds to wait for response\n          # Type: number | Required: No | Default: 1\n          timeoutSeconds: 1\n\n          # Consecutive successes before healthy\n          # Type: number | Required: No | Default: 1\n          successThreshold: 1\n\n          # Consecutive failures before unhealthy\n          # Type: number | Required: No | Default: 3\n          failureThreshold: 3\n\n        # Custom hostname configuration\n        hostnames:\n          # Custom hostname domain suffix\n          # Type: string | Required: No\n          host: ""\n          # AWS ACM certificate ARN for TLS\n          # Type: string | Required: No\n          acmARN: ""\n          # Internal DNS hostname fallback\n          # Type: string | Required: No\n          defaultInternalHostname: ""\n          # Default public URL fallback\n          # Type: string | Required: No\n          defaultPublicUrl: ""\n\n        # Network and routing configuration\n        network:\n          # IP addresses/CIDR ranges allowed to access service\n          # Type: array | Required: No\n          ipWhitelist:\n            - ""\n\n          # Map URL paths to container ports\n          # Type: object | Required: No\n          # Example: "/api": "8080", "/metrics": "9090"\n          pathPortMapping: {}\n\n          # Map external ports to container ports\n          # Type: object | Required: No\n          # Example: "80": "8080", "443": "8443"\n          hostPortMapping: {}\n\n          # gRPC configuration\n          grpc:\n            # Enable gRPC support\n            # Type: boolean | Required: No | Default: false\n            enable: false\n            # gRPC hostname\n            # Type: string | Required: No\n            host: ""\n            # Default gRPC hostname\n            # Type: string | Required: No\n            defaultHost: ""\n\n        # Persistent storage volumes\n        serviceDisks:\n          - # Unique volume identifier\n            # Type: string | Required: Yes\n            name: ""\n            # Container mount path\n            # Type: string | Required: Yes\n            mountPath: ""\n            # Volume size (e.g., "10Gi", "20Gi")\n            # Type: string | Required: Yes\n            storageSize: ""\n            # Volume access mode\n            # Type: string | Required: No | Default: "ReadWriteOnce"\n            # Valid values: "ReadWriteOnce", "ReadOnlyMany", "ReadWriteMany"\n            accessModes: "ReadWriteOnce"\n            # Storage medium\n            # Type: string | Required: No\n            # Valid values: "EBS", "DISK", "MEMORY"\n            # Note: EBS switches deployment to Recreate strategy\n            medium: ""\n\n        # Helm-based deployment for this service\n        helm:\n          # Enable Helm deployment\n          # Type: boolean | Required: No | Default: false\n          enabled: false\n          # Helm chart name\n          # Type: string | Required: No\n          chartName: ""\n          # Chart repository URL\n          # Type: string | Required: No\n          chartRepoUrl: ""\n          # Chart version\n          # Type: string | Required: No\n          chartVersion: ""\n          # Command to check status\n          # Type: string | Required: No\n          cmdPs: ""\n          # Helm action\n          # Type: string | Required: No | Default: "install"\n          # Valid values: "install", "upgrade"\n          action: "install"\n          # Custom values (key=value format)\n          # Type: array | Required: No\n          customValues:\n            - ""\n          # Custom value files\n          # Type: array | Required: No\n          customValueFiles:\n            - ""\n          # Helm CLI version\n          # Type: string | Required: No\n          helmVersion: ""\n          # PVC attachment configuration\n          attachPvc:\n            # Enable PVC attachment\n            # Type: boolean | Required: No | Default: false\n            enabled: false\n            # PVC mount path\n            # Type: string | Required: No\n            mountPath: ""\n\n        # Node selector labels for scheduling\n        # Type: object | Required: No\n        node_selector: {}\n\n        # Advanced node affinity rules (Kubernetes spec)\n        # Type: object | Required: No\n        node_affinity: {}\n\n  # --------------------------------------------------------------------------\n  # DOCKER SERVICE TYPE\n  # Deploy pre-built container images\n  # --------------------------------------------------------------------------\n  - name: ""\n    appShort: ""\n    defaultUUID: ""\n    requires: []\n    deploymentDependsOn: []\n\n    # Docker-specific configuration\n    docker:\n      # Docker image to deploy\n      # Type: string | Required: Yes\n      # Examples: "redis", "postgres", "123456789.dkr.ecr.us-east-1.amazonaws.com/my-app"\n      dockerImage: ""\n\n      # Default image tag\n      # Type: string | Required: Yes\n      # Examples: "latest", "7-alpine", "15-alpine"\n      defaultTag: ""\n\n      # Override container entrypoint\n      # Type: string | Required: No\n      command: ""\n\n      # Arguments passed to command\n      # Type: string | Required: No\n      # Use %%SPLIT%% delimiter for multiple args\n      arguments: ""\n\n      # Environment variables\n      # Type: object | Required: No\n      env: {}\n\n      # Exposed ports\n      # Type: array | Required: No | Default: ["8080"]\n      ports:\n        - ""\n\n      # Deployment configuration (same as github.deployment)\n      deployment:\n        public: false\n        capacityType: "SPOT"\n        resource:\n          cpu:\n            request: ""\n            limit: ""\n          memory:\n            request: ""\n            limit: ""\n        readiness:\n          disabled: false\n          tcpSocketPort: 0\n          httpGet:\n            path: ""\n            port: 0\n          initialDelaySeconds: 0\n          periodSeconds: 10\n          timeoutSeconds: 1\n          successThreshold: 1\n          failureThreshold: 3\n        hostnames:\n          host: ""\n          acmARN: ""\n          defaultInternalHostname: ""\n          defaultPublicUrl: ""\n        network:\n          ipWhitelist: []\n          pathPortMapping: {}\n          hostPortMapping: {}\n          grpc:\n            enable: false\n            host: ""\n            defaultHost: ""\n        serviceDisks: []\n        helm:\n          enabled: false\n          chartName: ""\n          chartRepoUrl: ""\n          chartVersion: ""\n          cmdPs: ""\n          action: "install"\n          customValues: []\n          customValueFiles: []\n          helmVersion: ""\n          attachPvc:\n            enabled: false\n            mountPath: ""\n        node_selector: {}\n        node_affinity: {}\n\n  # --------------------------------------------------------------------------\n  # HELM SERVICE TYPE\n  # Deploy using Helm charts (public, organization, or local)\n  # --------------------------------------------------------------------------\n  - name: ""\n    appShort: ""\n    defaultUUID: ""\n    requires: []\n    deploymentDependsOn: []\n\n    # Helm-specific configuration\n    helm:\n      # Deployment method\n      # Type: string | Required: No\n      # Valid values: "native", "ci"\n      # native: Kubernetes jobs (recommended, real-time logs)\n      # ci: External CI/CD system (legacy)\n      deploymentMethod: "native"\n\n      # Helm CLI version\n      # Type: string | Required: Yes (for native)\n      # Example: "3.12.0", "3.14.0"\n      version: "3.12.0"\n\n      # Additional Helm arguments\n      # Type: string | Required: No\n      # Example: "--wait --timeout 30m --atomic"\n      args: ""\n\n      # GitHub repository for local charts or value files\n      # Type: string | Required: Conditional\n      # Required for: local charts, org charts with images, public charts with valueFiles\n      repository: ""\n\n      # Branch to clone\n      # Type: string | Required: When repository is specified\n      branchName: ""\n\n      # Chart configuration\n      chart:\n        # Chart name or path\n        # Type: string | Required: Yes\n        # Public: "postgresql", "redis"\n        # Local: "./charts/my-app" or "../shared/chart"\n        # Organization: matches configured org chart name\n        name: ""\n\n        # Chart repository URL\n        # Type: string | Required: For public charts\n        # Standard: "https://charts.bitnami.com/bitnami"\n        # OCI: "oci://registry.example.com/charts"\n        repoUrl: ""\n\n        # Chart version\n        # Type: string | Required: Recommended\n        version: ""\n\n        # Custom values (key=value format)\n        # Type: array | Required: No\n        # Supports template variables and nested paths\n        values:\n          - "auth.username=admin"\n          - "persistence.enabled=true"\n\n        # Value files (relative to repo root)\n        # Type: array | Required: No\n        # Note: Completely replaces any defaults (no merging)\n        valueFiles:\n          - "helm/values/base.yaml"\n\n      # Environment variable mapping for Helm values\n      envMapping:\n        # App container env mapping\n        app:\n          # Format for transformation\n          # Type: string | Required: Yes (when envMapping.app specified)\n          # "array": path[0].name=KEY, path[0].value=VALUE\n          # "map": path.KEY=VALUE\n          format: "array"\n          # Helm value path for env vars\n          # Type: string | Required: Yes\n          path: "deployment.env"\n        # Init container env mapping (same structure)\n        init:\n          format: "array"\n          path: "deployment.initContainers[0].env"\n\n      # Docker build configuration (for org/local charts)\n      docker:\n        # Default image tag\n        # Type: string | Required: Yes (when docker specified)\n        defaultTag: "latest"\n\n        # Build engine\n        builder:\n          # Type: string | Valid values: "buildkit", "kaniko"\n          engine: "buildkit"\n\n        # App container configuration\n        app:\n          dockerfilePath: ""\n          command: ""\n          arguments: ""\n          env: {}\n          ports: []\n\n        # Init container configuration\n        init:\n          dockerfilePath: ""\n          command: ""\n          arguments: ""\n          env: {}\n\n      # Resource type for deployment\n      # Type: string | Required: No | Default: "deployment"\n      # Valid values: "deployment", "statefulset", "daemonset"\n      type: "deployment"\n\n      # Enable gRPC support\n      # Type: boolean | Required: No | Default: false\n      grpc: false\n\n      # Disable automatic ingress host\n      # Type: boolean | Required: No | Default: false\n      disableIngressHost: false\n\n      # Enable environment lens banner\n      # Type: boolean | Required: No | Default: false\n      envLens: false\n\n# ============================================================================\n# TEMPLATE VARIABLES REFERENCE\n# Use in env values: {{variable_name}} or {{{variable_name}}}\n# Triple braces {{{ }}} recommended to prevent URL encoding issues\n# ============================================================================\n# Build Variables:\n#   {{build_uuid}}              - Unique environment identifier\n#   {{build_namespace}}         - Kubernetes namespace\n#   {{build_publicUrl}}         - Environment\'s public URL\n#\n# Service Variables (replace \'service\' with actual service name):\n#   {{service_internalHostname}} - Internal DNS hostname\n#   {{service_publicUrl}}        - Public URL (if public: true)\n#   {{service_port}}             - First exposed port\n#\n# GitHub Variables:\n#   {{github_repository}}        - Repository name\n#   {{github_branch}}            - Branch name\n#   {{github_commit}}            - Commit SHA\n#   {{github_pr_number}}         - Pull request number\n```\n\n---\n\n## Schema Quick Reference\n\n### Environment Section\n\n| Field | Type | Required | Default | Description |\n|-------|------|----------|---------|-------------|\n| `autoDeploy` | boolean | No | `false` | Auto-deploy on PR open |\n| `githubDeployments` | boolean | No | `false` | Create GitHub Deployments |\n| `useGithubStatusComment` | boolean | No | `false` | Post PR comments |\n| `enabledFeatures` | array | No | `[]` | Feature flags |\n| `defaultServices` | array | No | `[]` | Always-deployed services |\n| `optionalServices` | array | No | `[]` | On-demand services |\n| `webhooks` | array | No | `[]` | Event automation |\n\n### Service Types\n\n| Type | Use Case | Uses `deployment` block |\n|------|----------|------------------------|\n| `github` | Build from source code | Yes |\n| `docker` | Deploy pre-built images | Yes |\n| `helm` | Deploy using Helm charts | No (use chart values) |\n\n### Capacity Types\n\n| Value | Description |\n|-------|-------------|\n| `ON_DEMAND` | Standard instances (production) |\n| `SPOT` | Cost-savings, interruptible (default) |\n\n### Webhook States\n\n| State | Trigger |\n|-------|---------|\n| `deployed` | All services successfully deployed |\n| `error` | Build or deployment failed |\n| `torn_down` | Environment cleaned up |\n\n### Build Engines\n\n| Engine | Description |\n|--------|-------------|\n| `buildkit` | Fast, efficient, better caching (recommended) |\n| `kaniko` | No Docker daemon required |',
  },
  {
    title: "Deployment Configuration",
    description:
      "Complete reference for deployment configuration options in the Lifecycle schema",
    date: "2025-01-29",
    path: "docs/schema/deployment-config",
    body: '## TL;DR\n\nThe `deployment` block controls how your service runs in Kubernetes: resources, health checks, networking, and storage.\n\n```\n+-------------------+     +--------------------+     +------------------+\n|   deployment:     | --> |  Kubernetes Pod    | --> |  Accessible via  |\n|   public: true    |     |  with resources,   |     |  Ingress URL or  |\n|   resource: {...} |     |  health checks,    |     |  internal DNS    |\n|   readiness: {...}|     |  storage attached  |     |                  |\n+-------------------+     +--------------------+     +------------------+\n```\n\n**Access via:** `docker.deployment` or `github.deployment`\n\n\nOnly applies to `docker` and `github` service types. Helm services configure these settings through chart values.\n\n\n---\n\n## Quick Reference\n\n| Field | Type | Default | Description |\n|-------|------|---------|-------------|\n| `public` | boolean | `false` | Create Ingress for external access |\n| `capacityType` | string | `SPOT` | `ON_DEMAND` or `SPOT` instances |\n| `resource` | object | - | CPU/memory requests and limits |\n| `readiness` | object | - | Health check configuration |\n| `hostnames` | object | - | Custom hostname and TLS |\n| `network` | object | - | Routing, IP whitelist, gRPC |\n| `serviceDisks` | array | - | Persistent storage volumes |\n| `helm` | object | - | Helm chart settings |\n| `node_selector` | object | - | Simple node selection labels |\n| `node_affinity` | object | - | Advanced node affinity rules |\n\n---\n\n## Common Patterns\n\n### Minimal Public API\n\n```yaml\ndeployment:\n  public: true\n  resource:\n    cpu: { request: "256m", limit: "512m" }\n    memory: { request: "512Mi", limit: "1Gi" }\n  readiness:\n    httpGet: { path: /health, port: 8080 }\n```\n\n### Database with Persistent Storage\n\n```yaml\ndeployment:\n  capacityType: ON_DEMAND  # Don\'t use SPOT for databases\n  serviceDisks:\n    - name: pgdata\n      mountPath: /var/lib/postgresql/data\n      storageSize: 20Gi\n      medium: EBS\n  readiness:\n    tcpSocketPort: 5432\n```\n\n### Background Worker (Internal Only)\n\n```yaml\ndeployment:\n  public: false  # No external access needed\n  capacityType: SPOT  # Cost-effective for interruptible work\n  resource:\n    cpu: { request: "100m", limit: "500m" }\n    memory: { request: "256Mi", limit: "512Mi" }\n  readiness:\n    disabled: true  # No health endpoint available\n```\n\n---\n\n## Common Mistakes\n\n### Resource Configuration\n\n```yaml\n# WRONG: Missing limits allows unbounded resource usage\ndeployment:\n  resource:\n    cpu:\n      request: "256m"\n    memory:\n      request: "512Mi"\n\n# CORRECT: Always set both request and limit\ndeployment:\n  resource:\n    cpu:\n      request: "256m"\n      limit: "512m"\n    memory:\n      request: "512Mi"\n      limit: "1Gi"\n```\n\n### Capacity Type for Stateful Services\n\n```yaml\n# WRONG: SPOT instances can be terminated, causing data loss\ndeployment:\n  capacityType: SPOT\n  serviceDisks:\n    - name: data\n      mountPath: /data\n      storageSize: 10Gi\n\n# CORRECT: Use ON_DEMAND for stateful workloads\ndeployment:\n  capacityType: ON_DEMAND\n  serviceDisks:\n    - name: data\n      mountPath: /data\n      storageSize: 10Gi\n```\n\n### Health Check Configuration\n\n```yaml\n# WRONG: No delay for slow-starting apps causes restarts\ndeployment:\n  readiness:\n    httpGet:\n      path: /health\n      port: 8080\n\n# CORRECT: Add initial delay for startup time\ndeployment:\n  readiness:\n    httpGet:\n      path: /health\n      port: 8080\n    initialDelaySeconds: 15\n    periodSeconds: 10\n    failureThreshold: 6\n```\n\n---\n\n## Ingress Configuration\n\n### `deployment.public`\n\n| Value | Ingress Created | GitHub Deployment Status | Access |\n|-------|-----------------|--------------------------|--------|\n| `true` | Yes | Enabled | External hostname |\n| `false` | No | Disabled | Internal DNS only |\n\n```yaml\ndeployment:\n  public: true\n```\n\n---\n\n## Capacity Type\n\n### `deployment.capacityType`\n\n| Value | Instance Type | Scheduling | Best For |\n|-------|---------------|------------|----------|\n| `SPOT` | Spot/preemptible | Preferred affinity | Dev, CI, stateless workers |\n| `ON_DEMAND` | Standard | Required affinity | Production, databases, stateful |\n\n\nSPOT instances may be interrupted with 2 minutes notice. Only use for fault-tolerant, stateless workloads.\n\n\n---\n\n## Resource Allocation\n\n### `deployment.resource`\n\n**Format Reference:**\n- CPU: `"100m"` (millicores), `"0.5"`, `"2"` (cores)\n- Memory: `"128Mi"`, `"512Mi"`, `"1Gi"`, `"2Gi"`\n\n| Field | Description |\n|-------|-------------|\n| `cpu.request` | Minimum CPU guaranteed (scheduling) |\n| `cpu.limit` | Maximum CPU allowed (throttled beyond) |\n| `memory.request` | Minimum memory guaranteed |\n| `memory.limit` | Maximum memory (OOMKilled beyond) |\n\n```yaml\ndeployment:\n  resource:\n    cpu:\n      request: "256m"\n      limit: "512m"\n    memory:\n      request: "512Mi"\n      limit: "1Gi"\n```\n\n---\n\n## Readiness Configuration\n\n### `deployment.readiness`\n\nDetermines when a pod is ready to receive traffic.\n\n| Field | Default | Description |\n|-------|---------|-------------|\n| `disabled` | `false` | Skip readiness checks entirely |\n| `httpGet.path` | - | HTTP endpoint path |\n| `httpGet.port` | - | HTTP endpoint port |\n| `tcpSocketPort` | - | TCP port check (alternative to HTTP) |\n| `initialDelaySeconds` | `0` | Wait before first check |\n| `periodSeconds` | `10` | Time between checks |\n| `timeoutSeconds` | `1` | Check timeout |\n| `successThreshold` | `1` | Consecutive successes to be ready |\n| `failureThreshold` | `30` | Consecutive failures to be unready |\n\n### HTTP vs TCP Health Checks\n\n```\nHTTP Check (web services):          TCP Check (databases, caches):\n+--------+    GET /health    +-----+  +--------+  TCP connect  +-----+\n| K8s    | ----------------> | App |  | K8s    | ------------> | DB  |\n+--------+    200 OK?        +-----+  +--------+  port open?   +-----+\n```\n\n**HTTP Check:**\n```yaml\ndeployment:\n  readiness:\n    httpGet:\n      path: /health\n      port: 8080\n    initialDelaySeconds: 10\n    periodSeconds: 15\n```\n\n**TCP Check:**\n```yaml\ndeployment:\n  readiness:\n    tcpSocketPort: 6379\n    initialDelaySeconds: 5\n```\n\n**Disable (not recommended):**\n```yaml\ndeployment:\n  readiness:\n    disabled: true\n```\n\n---\n\n## Hostname Configuration\n\n### `deployment.hostnames`\n\n| Field | Description |\n|-------|-------------|\n| `host` | Custom hostname domain suffix |\n| `acmARN` | AWS ACM certificate ARN for TLS |\n| `defaultInternalHostname` | Internal DNS name |\n| `defaultPublicUrl` | Default public URL |\n\n```yaml\ndeployment:\n  hostnames:\n    host: api.example.com\n    acmARN: arn:aws:acm:us-east-1:123456789:certificate/abc123\n```\n\n---\n\n## Network Configuration\n\n### `deployment.network`\n\n### IP Whitelisting\n\nRestrict access to specific IP ranges:\n\n```yaml\ndeployment:\n  network:\n    ipWhitelist:\n      - "10.0.0.0/8"       # Internal network\n      - "192.168.1.0/24"   # Office network\n```\n\n### Path-to-Port Mapping\n\nRoute different URL paths to different container ports:\n\n```\nRequest: /api/users  -->  Port 8080 (API server)\nRequest: /metrics    -->  Port 9090 (Prometheus)\n```\n\n```yaml\ndeployment:\n  network:\n    pathPortMapping:\n      /api: "8080"\n      /metrics: "9090"\n```\n\n### gRPC Configuration\n\n```yaml\ndeployment:\n  network:\n    grpc:\n      enable: true\n      host: grpc.example.com\n```\n\n---\n\n## Persistent Storage\n\n### `deployment.serviceDisks`\n\n| Field | Required | Description |\n|-------|----------|-------------|\n| `name` | Yes | Unique volume identifier |\n| `mountPath` | Yes | Container mount path |\n| `storageSize` | Yes | Volume size (e.g., `10Gi`) |\n| `accessModes` | No | `ReadWriteOnce` (default), `ReadOnlyMany`, `ReadWriteMany` |\n| `medium` | No | `EBS` (default), `DISK`, `MEMORY` |\n\n### Storage Medium Comparison\n\n| Medium | Persistence | Speed | Use Case |\n|--------|-------------|-------|----------|\n| `EBS` | Persistent | Standard | Databases, important data |\n| `MEMORY` | Ephemeral | Fast | Cache, temp files |\n\n\nEBS volumes can only attach to one node, so deployment strategy automatically switches to `Recreate`.\n\n\n```yaml\ndeployment:\n  serviceDisks:\n    - name: pgdata\n      mountPath: /var/lib/postgresql/data\n      storageSize: 20Gi\n      accessModes: ReadWriteOnce\n      medium: EBS\n```\n\n---\n\n## Node Scheduling\n\n### Simple Selection: `node_selector`\n\n```yaml\ndeployment:\n  node_selector:\n    disktype: ssd\n    environment: production\n```\n\n### Advanced Rules: `node_affinity`\n\n```yaml\ndeployment:\n  node_affinity:\n    requiredDuringSchedulingIgnoredDuringExecution:\n      nodeSelectorTerms:\n        - matchExpressions:\n            - key: kubernetes.io/instance-type\n              operator: In\n              values: [m5.large, m5.xlarge]\n```\n\n---\n\n## Helm Configuration\n\n### `deployment.helm`\n\nFor services deployed via Helm charts:\n\n| Field | Description |\n|-------|-------------|\n| `enabled` | Enable Helm deployment |\n| `chartName` | Chart name |\n| `chartRepoUrl` | Repository URL |\n| `chartVersion` | Chart version |\n| `customValues` | Array of `key=value` overrides |\n\n```yaml\ndeployment:\n  helm:\n    enabled: true\n    chartName: redis\n    chartRepoUrl: https://charts.bitnami.com/bitnami\n    chartVersion: 17.0.0\n    customValues:\n      - "replica.replicaCount=3"\n      - "auth.enabled=false"\n```\n\n---\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| Pod keeps restarting | Increase `initialDelaySeconds` for slow-starting apps |\n| OOMKilled errors | Increase `memory.limit` |\n| CPU throttling | Increase `cpu.limit` |\n| Pod won\'t schedule | Check `node_selector` labels exist on nodes |\n| SPOT interruptions | Switch to `capacityType: ON_DEMAND` |\n| EBS volume won\'t attach | EBS only supports `ReadWriteOnce` - check for stuck pods |\n\n---\n\n## Summary: When to Use What\n\n| Scenario | Key Settings |\n|----------|--------------|\n| Public web service | `public: true`, `readiness.httpGet`, resources |\n| Internal microservice | `public: false`, `readiness.httpGet` |\n| Database/stateful | `capacityType: ON_DEMAND`, `serviceDisks`, `readiness.tcpSocketPort` |\n| Background worker | `public: false`, `capacityType: SPOT`, `readiness.disabled: true` |\n| High-memory service | Larger `memory.limit`, consider `ON_DEMAND` |\n| Cost-sensitive dev | `capacityType: SPOT`, minimal resources |\n\n---\n\n## Complete Example\n\n```yaml\nservices:\n  - name: my-api\n    github:\n      repository: org/my-api\n      branchName: main\n      docker:\n        defaultTag: latest\n        app:\n          dockerfilePath: Dockerfile\n          ports:\n            - 8080\n      deployment:\n        public: true\n        capacityType: ON_DEMAND\n        resource:\n          cpu:\n            request: "500m"\n            limit: "1000m"\n          memory:\n            request: "1Gi"\n            limit: "2Gi"\n        readiness:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 15\n          periodSeconds: 10\n          timeoutSeconds: 5\n        hostnames:\n          host: api.example.com\n          acmARN: arn:aws:acm:us-east-1:123456789:certificate/abc\n        network:\n          ipWhitelist:\n            - "10.0.0.0/8"\n          pathPortMapping:\n            /api: "8080"\n            /metrics: "9090"\n        serviceDisks:\n          - name: app-data\n            mountPath: /data\n            storageSize: 10Gi\n            accessModes: ReadWriteOnce\n```',
  },
  {
    title: "Environment Configuration",
    description:
      "Complete documentation for the environment section of the Lifecycle schema",
    date: "2025-01-29",
    path: "docs/schema/environment",
    body: '# Environment Configuration\n\nThe `environment` object is the top-level configuration in `lifecycle.yaml` that controls global deployment behavior and defines which services are included.\n\n## Quick Reference\n\n| Field | Type | Default | Purpose |\n|-------|------|---------|---------|\n| `autoDeploy` | boolean | `false` | Auto-deploy on PR open |\n| `githubDeployments` | boolean | `false` | Create GitHub Deployments |\n| `useGithubStatusComment` | boolean | `false` | Post PR status comments (not implemented) |\n| `enabledFeatures` | array | `[]` | Feature flags |\n| `defaultServices` | array | `[]` | Always-deployed services |\n| `optionalServices` | array | `[]` | On-demand services |\n| `webhooks` | array | `[]` | Custom automation |\n\n---\n\n## Minimal vs Complete Example\n\n\n\n\n**Minimal Setup**\n\n```yaml filename=lifecycle.yaml\nversion: "1.0.0"\n\nenvironment:\n  defaultServices:\n    - name: "my-service"\n\nservices:\n  - name: "my-service"\n    # ... service config\n```\n\n\n\n\n**Full Featured**\n\n```yaml filename=lifecycle.yaml\nversion: "1.0.0"\n\nenvironment:\n  autoDeploy: true\n  githubDeployments: true\n  enabledFeatures:\n    - "no-default-env-resolve"\n  defaultServices:\n    - name: "api-service"\n    - name: "shared-db"\n      repository: "myorg/db"\n      branch: "main"\n  optionalServices:\n    - name: "debug-tools"\n  webhooks:\n    - name: "smoke-tests"\n      state: "deployed"\n      type: "docker"\n      docker:\n        image: "myorg/tests:latest"\n      env:\n        URL: "{{api-service_publicUrl}}"\n```\n\n\n\n\n---\n\n## Service Configuration\n\n### defaultServices vs optionalServices\n\n```\n+------------------+     +-------------------+\n| defaultServices  |     | optionalServices  |\n+------------------+     +-------------------+\n| Always deployed  |     | Deploy on demand  |\n| Core services    |     | Debug tools       |\n| Required deps    |     | Heavy services    |\n+------------------+     +-------------------+\n        |                        |\n        v                        v\n   Auto-start              Enable via PR UI\n```\n\n| Use Case | defaultServices | optionalServices |\n|----------|-----------------|------------------|\n| API server your app needs | Yes | No |\n| Database dependency | Yes | No |\n| Debug dashboard | No | Yes |\n| Resource-heavy analytics | No | Yes |\n| Mock payment service | No | Yes |\n\n### Service Object Fields\n\n| Field | Required | Description |\n|-------|----------|-------------|\n| `name` | Yes | Must match a defined service |\n| `repository` | Only for external | GitHub repo (`org/repo`) |\n| `branch` | Only for external | Branch to deploy |\n\n### WRONG vs CORRECT Examples\n\n\n\n\n**WRONG: External service missing fields**\n\n```yaml\nenvironment:\n  defaultServices:\n    # Missing repository and branch!\n    - name: "shared-database"\n```\n\n\n\n\n**CORRECT: External service with all fields**\n\n```yaml\nenvironment:\n  defaultServices:\n    - name: "shared-database"\n      repository: "myorg/shared-database"\n      branch: "main"\n```\n\n\n\n\n\n\n\n**WRONG: Local service with unnecessary fields**\n\n```yaml\nenvironment:\n  defaultServices:\n    # repository/branch ignored for local\n    - name: "api-service"\n      repository: "myorg/api"\n      branch: "main"\n```\n\n\n\n\n**CORRECT: Local service with name only**\n\n```yaml\nenvironment:\n  defaultServices:\n    # Defined in same lifecycle.yaml\n    - name: "api-service"\n```\n\n\n\n\n\nFor services defined in the same `lifecycle.yaml`, only `name` is needed. Use `repository` and `branch` only for external services from other repos.\n\n\n---\n\n## Deployment Behavior\n\n### autoDeploy\n\nControls whether environments deploy automatically when PRs are opened.\n\n| Setting | Behavior |\n|---------|----------|\n| `true` | Deploy immediately on PR open/reopen |\n| `false` (default) | Requires manual deploy label |\n\n```yaml\nenvironment:\n  autoDeploy: true  # Deploys automatically\n```\n\n### githubDeployments\n\nCreates native GitHub Deployments for tracking.\n\n| Setting | Behavior |\n|---------|----------|\n| `true` | Deployment status in PR timeline, history in Environments page |\n| `false` (default) | No GitHub integration |\n\n```yaml\nenvironment:\n  githubDeployments: true\n```\n\n### useGithubStatusComment\n\n\n**Not implemented.** This field exists in the schema but has no effect. Use the `lifecycle-status-comments!` label on PRs instead.\n\n\n---\n\n## Feature Flags\n\nEnable special behaviors via `enabledFeatures`:\n\n| Flag | Description |\n|------|-------------|\n| `no-default-env-resolve` | Prevents automatic resolution to default environment UUIDs for inactive services |\n| `hack-force-pull-request-branch` | Forces specific services to use the PR branch |\n| `hack-force-pull-request-service-` | Specifies which services use the PR branch hack |\n\n```yaml\nenvironment:\n  enabledFeatures:\n    - "no-default-env-resolve"\n```\n\n---\n\n## Webhooks\n\nRun custom automation when deployment state changes. See [Webhooks](/docs/features/webhooks) for full documentation.\n\n### Quick Setup\n\n```yaml\nenvironment:\n  webhooks:\n    - name: "run-tests"\n      state: "deployed"      # Trigger: deployed, error, torn_down\n      type: "docker"         # Type: docker, command, codefresh\n      docker:\n        image: "my-test-runner:latest"\n        timeout: 300\n      env:\n        API_URL: "{{api-service_publicUrl}}"\n```\n\n### Available Trigger States\n\n| State | When it fires |\n|-------|---------------|\n| `deployed` | All services successfully running |\n| `error` | Build or deployment failed |\n| `torn_down` | Environment destroyed |\n\n---\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| External service not deploying | Add `repository` and `branch` fields |\n| PR not auto-deploying | Set `autoDeploy: true` |\n| No GitHub status updates | Set `githubDeployments: true` |\n| Service in wrong environment | Check `defaultServices` vs `optionalServices` placement |\n| Webhook not firing | Verify `state` matches deployment outcome |\n\n---\n\n## Summary: When to Use What\n\n| I want to... | Use this |\n|--------------|----------|\n| Auto-deploy on every PR | `autoDeploy: true` |\n| Track deployments in GitHub UI | `githubDeployments: true` |\n| Always deploy a service | `defaultServices` |\n| Optionally deploy a service | `optionalServices` |\n| Include a service from another repo | Add `repository` + `branch` to service entry |\n| Run tests after deploy | `webhooks` with `state: deployed` |\n| Disable default env resolution | `enabledFeatures: ["no-default-env-resolve"]` |',
  },
  {
    title: "Docker Services Schema",
    description:
      "Complete reference for configuring Docker-type services in Lifecycle, including all deployment options, resource limits, readiness probes, and networking configuration.",
    date: "2025-03-28",
    path: "docs/schema/docker-services",
    body: '# Docker Services\n\nDeploy pre-built container images from any registry (Docker Hub, ECR, GCR) into your Lifecycle environment without building from source.\n\n## Quick Reference\n\n| Field | Required | Description |\n|-------|----------|-------------|\n| `name` | Yes | Unique service identifier |\n| `docker.dockerImage` | Yes | Image name (e.g., `redis`, `postgres`) |\n| `docker.defaultTag` | Yes | Image tag (e.g., `7-alpine`, `15`) |\n| `docker.ports` | No | Exposed ports (default: `[8080]`) |\n| `docker.env` | No | Environment variables |\n| `docker.deployment.public` | No | Create Ingress (default: `false`) |\n| `docker.deployment.capacityType` | No | `SPOT`, `ON_DEMAND`, or `FARGATE` |\n\n### Minimal Example\n\n```yaml filename="lifecycle.yaml"\nservices:\n  - name: "redis-cache"\n    docker:\n      dockerImage: "redis"\n      defaultTag: "7-alpine"\n      ports:\n        - 6379\n```\n\n---\n\n## Docker vs GitHub Services\n\n| Aspect | Docker Services | GitHub Services |\n|--------|-----------------|-----------------|\n| **Source** | Pre-built images from registries | Built from source code |\n| **Use case** | Third-party tools (Redis, Postgres, Grafana) | Your application code |\n| **Build step** | None | Dockerfile in repo |\n| **Configuration block** | `docker:` | `github:` |\n\n---\n\n## Common Patterns\n\n### Database with Persistent Storage\n\n```yaml filename="lifecycle.yaml"\nservices:\n  - name: "postgres-db"\n    docker:\n      dockerImage: "postgres"\n      defaultTag: "15-alpine"\n      ports:\n        - 5432\n      env:\n        POSTGRES_USER: "app_user"\n        POSTGRES_PASSWORD: "secure_password"\n        POSTGRES_DB: "myapp"\n        PGDATA: "/var/lib/postgresql/data/pgdata"\n      deployment:\n        capacityType: "ON_DEMAND"  # Don\'t use SPOT for databases\n        readiness:\n          tcpSocketPort: 5432\n          initialDelaySeconds: 15\n        serviceDisks:\n          - name: "postgres-data"\n            mountPath: "/var/lib/postgresql/data"\n            storageSize: "20Gi"\n```\n\n### Cache Service (Redis)\n\n```yaml filename="lifecycle.yaml"\nservices:\n  - name: "redis-cache"\n    docker:\n      dockerImage: "redis"\n      defaultTag: "7-alpine"\n      ports:\n        - 6379\n      command: "redis-server"\n      arguments: "--maxmemory%%SPLIT%%512mb%%SPLIT%%--maxmemory-policy%%SPLIT%%allkeys-lru"\n      deployment:\n        capacityType: "SPOT"  # OK for caches\n        readiness:\n          tcpSocketPort: 6379\n```\n\n### Public Web Service\n\n```yaml filename="lifecycle.yaml"\nservices:\n  - name: "grafana"\n    docker:\n      dockerImage: "grafana/grafana"\n      defaultTag: "10.0.0"\n      ports:\n        - 3000\n      env:\n        GF_SECURITY_ADMIN_PASSWORD: "admin"\n      deployment:\n        public: true\n        readiness:\n          httpGet:\n            path: "/api/health"\n            port: 3000\n```\n\n---\n\n## WRONG vs CORRECT Examples\n\n### Arguments Syntax\n\n\n\n```yaml\n# WRONG: Space-separated arguments\narguments: "--maxmemory 512mb --maxmemory-policy allkeys-lru"\n```\n\n\n```yaml\n# CORRECT: Use %%SPLIT%% delimiter\narguments: "--maxmemory%%SPLIT%%512mb%%SPLIT%%--maxmemory-policy%%SPLIT%%allkeys-lru"\n```\n\n\n\n### Database Capacity Type\n\n\n\n```yaml\n# WRONG: SPOT instances can be interrupted\n- name: "postgres-db"\n  docker:\n    dockerImage: "postgres"\n    deployment:\n      capacityType: "SPOT"  # Data loss risk!\n```\n\n\n```yaml\n# CORRECT: Use ON_DEMAND for stateful services\n- name: "postgres-db"\n  docker:\n    dockerImage: "postgres"\n    deployment:\n      capacityType: "ON_DEMAND"\n```\n\n\n\n### Health Check Configuration\n\n\n\n```yaml\n# WRONG: Using both tcpSocketPort AND httpGet\nreadiness:\n  tcpSocketPort: 6379\n  httpGet:\n    path: "/health"\n    port: 8080\n```\n\n\n```yaml\n# CORRECT: Use ONE health check type\n# For TCP services (Redis, Postgres):\nreadiness:\n  tcpSocketPort: 6379\n\n# For HTTP services (APIs, web apps):\nreadiness:\n  httpGet:\n    path: "/health"\n    port: 8080\n```\n\n\n\n---\n\n## Service-Level Properties\n\n### `name` (required)\n\nUnique identifier for the service. Used in deployment configs, environment variables, and hostnames.\n\n```yaml\nservices:\n  - name: "redis-cache"  # Must be unique across all services\n```\n\n### `requires`\n\nServices that must be deployed together with this service.\n\n```yaml\nservices:\n  - name: "my-app"\n    requires:\n      - name: "redis-cache"\n      - name: "postgres-db"\n```\n\n### `deploymentDependsOn`\n\nControls deployment order without creating hard dependencies.\n\n```yaml\nservices:\n  - name: "api-server"\n    deploymentDependsOn:\n      - "database"    # Deploy database first\n      - "cache"       # Then cache\n                      # Then api-server\n```\n\n**Difference from `requires`:**\n- `requires`: Auto-includes services AND controls order\n- `deploymentDependsOn`: Only controls order (services must be explicitly deployed)\n\n### `appShort` and `defaultUUID`\n\n| Property | Purpose |\n|----------|---------|\n| `appShort` | Short identifier for registry paths (`{registry}/{appShort}/lfc`) |\n| `defaultUUID` | Fallback UUID for hostnames when not deployed |\n\n---\n\n## Docker Configuration\n\n### `docker.dockerImage` and `docker.defaultTag` (required)\n\n```yaml\ndocker:\n  # Public Docker Hub image\n  dockerImage: "redis"\n  defaultTag: "7-alpine"\n\n  # Private ECR image\n  dockerImage: "123456789.dkr.ecr.us-east-1.amazonaws.com/my-app"\n  defaultTag: "v1.2.3"\n\n  # Google Container Registry\n  dockerImage: "gcr.io/my-project/my-image"\n  defaultTag: "latest"\n```\n\n### `docker.command` and `docker.arguments`\n\nOverride the container\'s entrypoint and arguments.\n\n```yaml\ndocker:\n  dockerImage: "redis"\n  defaultTag: "7-alpine"\n  command: "redis-server"\n  arguments: "--maxmemory%%SPLIT%%512mb%%SPLIT%%--port%%SPLIT%%6380"\n```\n\n}>\nUse `%%SPLIT%%` to separate arguments. Each segment becomes a separate argument passed to the container.\n\n\n### `docker.env`\n\nEnvironment variables as key-value pairs.\n\n```yaml\ndocker:\n  dockerImage: "postgres"\n  defaultTag: "15-alpine"\n  env:\n    POSTGRES_USER: "myuser"\n    POSTGRES_PASSWORD: "mypassword"\n    POSTGRES_DB: "mydatabase"\n```\n\n### `docker.ports`\n\nExposed container ports. First port is used for health checks and routing.\n\n```yaml\ndocker:\n  ports:\n    - 8080        # Primary port\n    - 8443        # HTTPS\n    - 9090        # Metrics\n```\n\nDefault: `[8080]`\n\n---\n\n## Deployment Configuration\n\n### `deployment.public`\n\n| Value | Behavior |\n|-------|----------|\n| `false` (default) | Internal cluster access only |\n| `true` | Creates Kubernetes Ingress for external access |\n\n}>\nExternal reachability depends on your cluster\'s network configuration (VPN, firewall, load balancer).\n\n\n### `deployment.capacityType`\n\n| Type | Cost | Availability | Best For |\n|------|------|--------------|----------|\n| `SPOT` (default) | Lowest | May be interrupted | Stateless workers, caches |\n| `ON_DEMAND` | Standard | Guaranteed | Databases, critical services |\n| `FARGATE` | Variable | Serverless | Burst workloads |\n\n---\n\n## Resource Configuration\n\n```\n+------------------+     +------------------+\n|   CPU Units      |     |  Memory Units    |\n+------------------+     +------------------+\n| 100m  = 0.1 CPU  |     | 128Mi = 128 MB   |\n| 500m  = 0.5 CPU  |     | 512Mi = 512 MB   |\n| 1000m = 1 CPU    |     | 1Gi   = 1 GB     |\n| 2000m = 2 CPUs   |     | 2Gi   = 2 GB     |\n+------------------+     +------------------+\n```\n\n```yaml\ndeployment:\n  resource:\n    cpu:\n      request: "250m"    # Guaranteed minimum\n      limit: "1000m"     # Maximum allowed\n    memory:\n      request: "512Mi"\n      limit: "2Gi"\n```\n\n---\n\n## Readiness Configuration\n\nHealth checks determine when the service is ready for traffic.\n\n### TCP Health Check (for databases, caches)\n\n```yaml\ndeployment:\n  readiness:\n    tcpSocketPort: 6379\n    initialDelaySeconds: 5\n    periodSeconds: 10\n    failureThreshold: 3\n```\n\n### HTTP Health Check (for web services)\n\n```yaml\ndeployment:\n  readiness:\n    httpGet:\n      path: "/health"\n      port: 8080\n    initialDelaySeconds: 10\n    periodSeconds: 5\n    timeoutSeconds: 3\n    successThreshold: 1\n    failureThreshold: 3\n```\n\n### Readiness Properties\n\n| Property | Description | Default |\n|----------|-------------|---------|\n| `disabled` | Skip health checks entirely | `false` |\n| `initialDelaySeconds` | Wait before first check | System default |\n| `periodSeconds` | Interval between checks | System default |\n| `timeoutSeconds` | Timeout per check | System default |\n| `successThreshold` | Consecutive successes needed | System default |\n| `failureThreshold` | Consecutive failures before unhealthy | System default |\n\n---\n\n## Hostname Configuration\n\n```yaml\ndeployment:\n  public: true\n  hostnames:\n    host: "api.example.com"\n    acmARN: "arn:aws:acm:us-east-1:123456789:certificate/abc-123"\n    defaultInternalHostname: "api-gateway-default"\n    defaultPublicUrl: "https://api-default.example.com"\n```\n\n| Property | Purpose |\n|----------|---------|\n| `host` | Base domain for the service |\n| `acmARN` | AWS ACM certificate for HTTPS |\n| `defaultInternalHostname` | Fallback internal hostname when inactive |\n| `defaultPublicUrl` | Fallback public URL when inactive |\n\n---\n\n## Network Configuration\n\n### IP Whitelisting\n\n```yaml\ndeployment:\n  network:\n    ipWhitelist:\n      - "10.0.0.0/8"         # Private network\n      - "192.168.1.0/24"     # Specific subnet\n      - "203.0.113.50/32"    # Single IP\n```\n\n### Path-to-Port Mapping\n\nRoute different URL paths to different container ports.\n\n```yaml\ndocker:\n  ports:\n    - 8080\n    - 9090\ndeployment:\n  network:\n    pathPortMapping:\n      "/api": "8080"\n      "/metrics": "9090"\n```\n\n### gRPC Support\n\n```yaml\ndeployment:\n  network:\n    grpc:\n      enable: true\n      host: "grpc.example.com"\n```\n\n---\n\n## Persistent Storage\n\n```yaml\ndeployment:\n  serviceDisks:\n    - name: "postgres-data"\n      mountPath: "/var/lib/postgresql/data"\n      storageSize: "20Gi"\n      accessModes: "ReadWriteOnce"\n      medium: "gp2"\n```\n\n### Access Modes\n\n| Mode | Description |\n|------|-------------|\n| `ReadWriteOnce` | Single node read-write (default) |\n| `ReadOnlyMany` | Multi-node read-only |\n| `ReadWriteMany` | Multi-node read-write |\n\n---\n\n## Node Selection (Advanced)\n\n### Simple Node Selector\n\n```yaml\ndeployment:\n  node_selector:\n    gpu: "true"\n    instance-type: "p3.2xlarge"\n```\n\n### Node Affinity Rules\n\n```yaml\ndeployment:\n  node_affinity:\n    requiredDuringSchedulingIgnoredDuringExecution:\n      nodeSelectorTerms:\n        - matchExpressions:\n            - key: "topology.kubernetes.io/zone"\n              operator: "In"\n              values:\n                - "us-east-1a"\n                - "us-east-1b"\n```\n\n---\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| Service not accessible externally | Set `deployment.public: true` and verify cluster network config |\n| Container keeps restarting | Check `readiness` probe settings; increase `initialDelaySeconds` |\n| Arguments not parsed correctly | Use `%%SPLIT%%` delimiter between each argument |\n| Database data lost on restart | Add `serviceDisks` with persistent storage |\n| Pod scheduled on wrong node type | Check `capacityType` or add `node_selector` |\n| Health check failing | Verify port matches exposed port; check if service needs warmup time |\n\n---\n\n## When to Use What\n\n| Scenario | Configuration |\n|----------|---------------|\n| **Redis/Memcached cache** | `capacityType: SPOT`, TCP readiness probe |\n| **PostgreSQL/MySQL database** | `capacityType: ON_DEMAND`, TCP probe, `serviceDisks` |\n| **Public API gateway** | `public: true`, HTTP probe, `hostnames` |\n| **Internal microservice** | `public: false`, HTTP probe |\n| **GPU workload** | `node_selector` with GPU labels |\n| **gRPC service** | `network.grpc.enable: true` |\n| **Multi-port service** | `pathPortMapping` for routing |\n\n---\n\n## Complete Field Reference\n\n### Service-Level\n\n| Field | Required | Type | Default |\n|-------|----------|------|---------|\n| `name` | Yes | string | - |\n| `appShort` | No | string | - |\n| `defaultUUID` | No | string | System UUID |\n| `requires` | No | array | `[]` |\n| `deploymentDependsOn` | No | array | `[]` |\n\n### Docker Block\n\n| Field | Required | Type | Default |\n|-------|----------|------|---------|\n| `docker.dockerImage` | Yes | string | - |\n| `docker.defaultTag` | Yes | string | - |\n| `docker.command` | No | string | Image default |\n| `docker.arguments` | No | string | - |\n| `docker.env` | No | object | `{}` |\n| `docker.ports` | No | array | `[8080]` |\n\n### Deployment Block\n\n| Field | Required | Type | Default |\n|-------|----------|------|---------|\n| `deployment.public` | No | boolean | `false` |\n| `deployment.capacityType` | No | string | `"SPOT"` |\n| `deployment.resource.cpu.request` | No | string | System default |\n| `deployment.resource.cpu.limit` | No | string | - |\n| `deployment.resource.memory.request` | No | string | System default |\n| `deployment.resource.memory.limit` | No | string | - |\n\n### Readiness Block\n\n| Field | Required | Type | Default |\n|-------|----------|------|---------|\n| `readiness.disabled` | No | boolean | `false` |\n| `readiness.tcpSocketPort` | No | number | System default |\n| `readiness.httpGet.path` | No | string | System default |\n| `readiness.httpGet.port` | No | number | System default |\n| `readiness.initialDelaySeconds` | No | number | System default |\n| `readiness.periodSeconds` | No | number | System default |\n| `readiness.timeoutSeconds` | No | number | System default |\n| `readiness.successThreshold` | No | number | System default |\n| `readiness.failureThreshold` | No | number | System default |\n\n### Hostnames Block\n\n| Field | Required | Type | Default |\n|-------|----------|------|---------|\n| `hostnames.host` | No | string | System domain |\n| `hostnames.acmARN` | No | string | System default |\n| `hostnames.defaultInternalHostname` | No | string | Auto-generated |\n| `hostnames.defaultPublicUrl` | No | string | Auto-generated |\n\n### Network Block\n\n| Field | Required | Type | Default |\n|-------|----------|------|---------|\n| `network.ipWhitelist` | No | array | System default |\n| `network.pathPortMapping` | No | object | `{}` |\n| `network.hostPortMapping` | No | object | `{}` |\n| `network.grpc.enable` | No | boolean | `false` |\n| `network.grpc.host` | No | string | System gRPC domain |\n| `network.grpc.defaultHost` | No | string | Auto-generated |\n\n### Service Disks\n\n| Field | Required | Type | Default |\n|-------|----------|------|---------|\n| `serviceDisks[].name` | Yes | string | - |\n| `serviceDisks[].mountPath` | Yes | string | - |\n| `serviceDisks[].storageSize` | Yes | string | - |\n| `serviceDisks[].accessModes` | No | string | `"ReadWriteOnce"` |\n| `serviceDisks[].medium` | No | string | - |\n\n### Node Scheduling\n\n| Field | Required | Type | Default |\n|-------|----------|------|---------|\n| `node_selector` | No | object | `null` |\n| `node_affinity` | No | object | `null` |',
  },
  {
    title: "GitHub Services",
    description: "Configure services that build from GitHub source code",
    date: "2025-01-29",
    path: "docs/schema/github-services",
    body: '## GitHub Services\n\nBuild and deploy Docker images directly from your GitHub repositories.\n\n### Quick Reference\n\n| Field | Required | Description |\n|-------|----------|-------------|\n| `github.repository` | Yes | Repository in `org/repo` format |\n| `github.branchName` | Yes | Default branch to build from |\n| `github.docker.defaultTag` | Yes | Fallback image tag (e.g., `latest`) |\n| `github.docker.app.dockerfilePath` | Yes | Path to Dockerfile |\n| `github.docker.app.ports` | No | Container ports (default: `[8080]`) |\n| `github.docker.builder.engine` | No | `buildkit` or `kaniko` |\n\n---\n\n## Minimal Configuration\n\n```yaml filename=lifecycle.yaml\nservices:\n  - name: "my-api"\n    github:\n      repository: "myorg/my-api"\n      branchName: "main"\n      docker:\n        defaultTag: "latest"\n        app:\n          dockerfilePath: "Dockerfile"\n          ports:\n            - 8080\n```\n\n---\n\n## Build Engine Comparison\n\n| Engine | Best For | Notes |\n|--------|----------|-------|\n| `buildkit` | Most use cases | Faster builds, better caching |\n| `kaniko` | Restricted environments | No Docker daemon required |\n\n```yaml\ngithub:\n  docker:\n    builder:\n      engine: "buildkit"  # Recommended default\n```\n\n---\n\n## Common Patterns\n\n### Web API with Database\n\n```yaml\nservices:\n  - name: "api"\n    requires:\n      - name: "database"\n    deploymentDependsOn:\n      - "database"\n    github:\n      repository: "myorg/api"\n      branchName: "main"\n      docker:\n        defaultTag: "latest"\n        builder:\n          engine: "buildkit"\n        app:\n          dockerfilePath: "Dockerfile"\n          ports:\n            - 8080\n          env:\n            DATABASE_URL: "postgres://{{database_internalHostname}}:5432/app"\n```\n\n### Service with Database Migrations (Init Container)\n\n```yaml\ngithub:\n  docker:\n    init:\n      dockerfilePath: "Dockerfile.migrate"\n      command: "/bin/sh"\n      arguments: "-c%%SPLIT%%npm run migrate"\n      env:\n        DATABASE_URL: "postgres://{{database_internalHostname}}:5432/app"\n    app:\n      dockerfilePath: "Dockerfile"\n      ports:\n        - 8080\n```\n\n\nInit containers run **before** the main app container. Use them for migrations, config setup, or health checks.\n\n\n### Custom Entrypoint with Arguments\n\nUse `%%SPLIT%%` to separate command arguments:\n\n```yaml\ngithub:\n  docker:\n    app:\n      dockerfilePath: "Dockerfile"\n      command: "node"\n      arguments: "server.js%%SPLIT%%--port%%SPLIT%%8080"\n```\n\nThis translates to: `node server.js --port 8080`\n\n---\n\n## Common Mistakes\n\n### WRONG: Missing required fields\n\n```yaml\nservices:\n  - name: "my-api"\n    github:\n      repository: "myorg/my-api"\n      # Missing: branchName, docker.defaultTag, docker.app.dockerfilePath\n```\n\n### CORRECT: All required fields present\n\n```yaml\nservices:\n  - name: "my-api"\n    github:\n      repository: "myorg/my-api"\n      branchName: "main"\n      docker:\n        defaultTag: "latest"\n        app:\n          dockerfilePath: "Dockerfile"\n```\n\n### WRONG: Arguments as array\n\n```yaml\ngithub:\n  docker:\n    app:\n      arguments:\n        - "server.js"\n        - "--port"\n        - "8080"\n```\n\n### CORRECT: Arguments with `%%SPLIT%%` delimiter\n\n```yaml\ngithub:\n  docker:\n    app:\n      arguments: "server.js%%SPLIT%%--port%%SPLIT%%8080"\n```\n\n---\n\n## Field Reference\n\n### Service-Level Fields\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `name` | string | Yes | Unique service identifier |\n| `appShort` | string | No | Short identifier for registry organization |\n| `defaultUUID` | string | No | Fallback UUID for inactive services |\n| `requires` | array | No | Service dependencies (affects service discovery) |\n| `deploymentDependsOn` | array | No | Deployment order (affects startup sequence) |\n\n### GitHub Configuration\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `repository` | string | Yes | Format: `org/repo` |\n| `branchName` | string | Yes | Default branch (PR environments override this) |\n\n### Docker Configuration\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `defaultTag` | string | Yes | Tag when not building from specific commit |\n| `ecr` | string | No | Custom ECR URL (otherwise uses default registry) |\n| `pipelineId` | string | No | External CI/CD pipeline ID (Codefresh) |\n| `builder.engine` | string | No | `buildkit` or `kaniko` |\n\n### App Container\n\n| Field | Type | Required | Default | Description |\n|-------|------|----------|---------|-------------|\n| `dockerfilePath` | string | Yes | - | Path relative to repo root |\n| `command` | string | No | - | Override container entrypoint |\n| `arguments` | string | No | - | Args with `%%SPLIT%%` delimiter |\n| `env` | object | No | - | Environment variables (supports templates) |\n| `ports` | number[] | No | `[8080]` | Exposed container ports |\n\n### Init Container\n\nSame fields as app container (`dockerfilePath`, `command`, `arguments`, `env`). Runs before the main container.\n\n### After Build Pipeline\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `afterBuildPipelineConfig.afterBuildPipelineId` | string | Pipeline ID to trigger |\n| `afterBuildPipelineConfig.detatchAfterBuildPipeline` | boolean | Run asynchronously |\n| `afterBuildPipelineConfig.description` | string | Pipeline description |\n\n---\n\n## Deployment Configuration\n\nSee [Deployment Configuration](/docs/schema/deployment-config) for full options. Quick example:\n\n```yaml\ngithub:\n  deployment:\n    public: true\n    capacityType: "SPOT"\n    resource:\n      cpu:\n        request: "256m"\n        limit: "512m"\n      memory:\n        request: "512Mi"\n        limit: "1Gi"\n    readiness:\n      httpGet:\n        path: "/health"\n        port: 8080\n    hostnames:\n      host: "api.example.com"\n```\n\n---\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| Build fails to find Dockerfile | Verify `dockerfilePath` is relative to repo root |\n| Init container never completes | Check init container logs; ensure it exits with code 0 |\n| Service can\'t reach dependency | Use template variables: `{{service_internalHostname}}` |\n| Arguments not parsed correctly | Use `%%SPLIT%%` between each argument |\n| Image not found | Check `defaultTag` matches an existing image |\n\n---\n\n## Complete Example\n\n```yaml filename=lifecycle.yaml\nservices:\n  - name: "backend-api"\n    appShort: "api"\n    defaultUUID: "dev-0"\n    requires:\n      - name: "database"\n    deploymentDependsOn:\n      - "database"\n      - "cache"\n    github:\n      repository: "myorg/backend-api"\n      branchName: "main"\n      docker:\n        defaultTag: "latest"\n        builder:\n          engine: "buildkit"\n        init:\n          dockerfilePath: "docker/migrate.Dockerfile"\n          command: "/bin/sh"\n          arguments: "-c%%SPLIT%%npm run db:migrate"\n          env:\n            DATABASE_URL: "postgres://{{database_internalHostname}}:5432/app"\n        app:\n          dockerfilePath: "Dockerfile"\n          command: "node"\n          arguments: "dist/server.js"\n          ports:\n            - 8080\n            - 9090\n          env:\n            NODE_ENV: "production"\n            DATABASE_URL: "postgres://{{database_internalHostname}}:5432/app"\n            REDIS_URL: "redis://{{cache_internalHostname}}:6379"\n      deployment:\n        public: true\n        capacityType: "SPOT"\n        resource:\n          cpu:\n            request: "256m"\n            limit: "1000m"\n          memory:\n            request: "512Mi"\n            limit: "2Gi"\n        readiness:\n          httpGet:\n            path: "/health"\n            port: 8080\n          initialDelaySeconds: 15\n          periodSeconds: 10\n        hostnames:\n          host: "api.lifecycle.example.com"\n```\n\n---\n\n## Summary: When to Use What\n\n| Scenario | Configuration |\n|----------|---------------|\n| Simple web service | Minimal config with `dockerfilePath` and `ports` |\n| Database migrations on deploy | Add `init` container with migration command |\n| Service needs another service | Add to `requires` and use `{{name_internalHostname}}` |\n| Control startup order | Use `deploymentDependsOn` |\n| Custom registry | Set `docker.ecr` |\n| No Docker daemon available | Use `builder.engine: "kaniko"` |\n| Run tests after build | Configure `afterBuildPipelineConfig` |',
  },
  {
    title: "Terminology",
    description: null,
    date: null,
    path: "docs/getting-started/terminology",
    body: '# Terminology\n\n## Quick Reference\n\n| Term | Definition |\n|------|------------|\n| **Environment** | A stack of connected services (ephemeral or static) |\n| **Service** | A deployable artifact (Docker, Helm, GitHub, etc.) |\n| **Build** | The process instance that builds and deploys services |\n| **Deploy** | Execution of a single service within a build |\n| **Repository** | A GitHub repo registered with Lifecycle |\n| **UUID** | Unique identifier for builds (e.g., `arm-model-060825`) |\n\n## How Lifecycle Components Relate\n\n(GitHub + lifecycle.yaml)"]\n    end\n\n    repo -->|"Pull Request opened"| env\n\n    subgraph env["ENVIRONMENT (UUID: arm-model-060825)"]\n        subgraph build["BUILD"]\n            deploy1["DEPLOYservice-a"]\n            deploy2["DEPLOYservice-b"]\n            deploy3["DEPLOYservice-c"]\n        end\n    end\n\n    env --> ns\n\n    subgraph ns["KUBERNETES NAMESPACE(env-arm-model-060825)"]\n    end\n`} />\n\n---\n\n## Core Concepts\n\n### Environment\n\nA stack of services built and connected together. Two types exist:\n\n| Type | Lifespan | Use Case |\n|------|----------|----------|\n| **Ephemeral** | Tied to PR lifecycle | Feature branch testing |\n| **Static** | Long-lived (e.g., `dev-0`) | Fallback for optional services |\n\nEnvironments define **defaultServices** (always deployed) and **optionalServices** (deployed on demand).\n\n### Service\n\nA deployable artifact defined in `lifecycle.yaml`.\n\n| Type | Description |\n|------|-------------|\n| `docker` | Container built from a Dockerfile |\n| `github` | Built from GitHub source code |\n| `helm` | Helm chart deployment |\n| `codefresh` | Codefresh pipeline-managed deployment |\n| `configuration` | Configuration-only (no build) |\n\nA single repository can contain multiple services.\n\n### Build\n\nThe process instance that builds and deploys all services in an environment. Each build:\n\n- Has a unique UUID (e.g., `arm-model-060825`)\n- Contains one deploy per service\n- Tracks overall environment status\n\n### Deploy\n\nThe execution of a single service within a build. Manages building the Docker image and deploying to Kubernetes.\n\n---\n\n## Status Reference\n\n### Build Status\n\n queued --> building --> built --> deploying --> deployed\n    deployed --> tearing_down --> torn_down\n    deployed --> error\n    deployed --> config_error\n`} />\n\n| Status | Meaning |\n|--------|---------|\n| `pending` | Being prepared |\n| `queued` | Waiting to be processed |\n| `building` | Docker images building |\n| `built` | All images built successfully |\n| `deploying` | Deploying to Kubernetes |\n| `deployed` | All services running |\n| `tearing_down` | Being deleted |\n| `torn_down` | Fully deleted |\n| `error` | Build or deploy failed |\n| `config_error` | Invalid `lifecycle.yaml` |\n\n### Deploy Status\n\n| Status | Meaning |\n|--------|---------|\n| `pending` | Waiting to start |\n| `queued` | In the queue |\n| `cloning` | Cloning source code |\n| `building` | Building Docker image |\n| `built` | Image built |\n| `deploying` | Deploying to Kubernetes |\n| `ready` | Running and healthy |\n| `waiting` | Waiting for dependencies |\n| `build_failed` | Image build failed |\n| `deploy_failed` | Kubernetes deployment failed |\n| `error` | Unexpected error |\n| `torn_down` | Service removed |\n\n---\n\n## GitHub Integration\n\n### Labels\n\n| Label | Effect |\n|-------|--------|\n| `lifecycle-deploy!` | Triggers deployment |\n| `lifecycle-disabled!` | Deletes the environment |\n| `lifecycle-keep!` | Prevents TTL cleanup |\n| `lifecycle-status-comments!` | Enables detailed status comments |\n\n### Mission Control Comment\n\nPosted by Lifecycle on your PR. Provides:\n- Build status and service URLs\n- Checkboxes to enable/disable services\n- Configuration overrides\n\n### Webhooks\n\nInvoke external services on build state changes. Example uses:\n- Trigger E2E tests when `deployed`\n- Send notifications on `error`\n\n---\n\n## Infrastructure\n\n### Namespace\n\nKubernetes namespace where your environment runs. Format: `env-`\n\n### UUID\n\nHuman-readable identifier using haikunator pattern (e.g., `arm-model-060825`). Used for:\n- Environment identification\n- Namespace naming\n- URL generation\n\n### Template Variables\n\nPlaceholders resolved at build time:\n\n| Variable | Resolves To |\n|----------|-------------|\n| `{{{service_publicUrl}}}` | Public URL of a service |\n| `{{{service_internalHostname}}}` | Internal Kubernetes hostname |\n\n### TTL (Time-To-Live)\n\nAutomatic cleanup of inactive environments.\n\n- **Inactivity period**: 14 days\n- **Check interval**: 4 hours\n- **Override**: Add `lifecycle-keep!` label\n\n### Capacity Type\n\n| Type | Description |\n|------|-------------|\n| `ON_DEMAND` | Standard, always-available compute |\n| `SPOT` | Cost-effective (may be interrupted) |',
  },
  {
    title: "Explore static environment",
    description: "Create the first and default static environment",
    date: null,
    path: "docs/getting-started/explore-static-environment",
    body: '## Quick Reference\n\n| Property | Value |\n|----------|-------|\n| Default UUID | `dev-0` |\n| Repository | `lifecycle-static-env` |\n| Config file | `lifecycle.yaml` (root) |\n| Deploy label | `lifecycle-deploy!` |\n| Database flags | `trackDefaultBranches = true`, `isStatic = true` |\n\n## What is a Static Environment?\n\nA **static environment** is a persistent, long-lived environment that auto-updates when changes merge to default branches. It serves as the fallback for services not explicitly built in ephemeral environments.\n\n static\n    backend --> static\n`} />\n\n\nThe `dev-0` environment must be created manually. The bootstrap process creates the record but does not build any services.\n\n\n## Static vs Ephemeral\n\n| Aspect | Static | Ephemeral |\n|--------|--------|-----------|\n| Lifespan | Persistent | PR lifecycle |\n| Updates | Auto on merge to main | Manual/PR updates |\n| Cleanup | Manual only | Auto on PR close |\n| Example | `dev-0` | `feature-123` |\n\n## Create `dev-0`\n\n### Step 1: Delete Bootstrap Record\n\n```sql\nDELETE FROM builds WHERE uuid = \'dev-0\';\n```\n\n### Step 2: Create Repository\n\nCreate `lifecycle-static-env` repository in your GitHub account.\n\n### Step 3: Install GitHub App\n\nInstall the Lifecycle GitHub App on the new repository.\n\n### Step 4: Add Configuration\n\nCreate a PR from branch `dev-0` with `lifecycle.yaml`:\n\n```yaml filename="lifecycle.yaml"\nenvironment:\n  defaultServices:\n    - name: "frontend"\n      repository: "account/frontend-repo"\n      branch: "main"\n    - name: "backend"\n      repository: "account/backend-api"\n      branch: "main"\n    - name: "database"\n      repository: "account/database-service"\n      branch: "main"\n```\n\n### Step 5: Deploy\n\nAdd `lifecycle-deploy!` label to the PR.\n\n### Step 6: Set UUID\n\nUpdate UUID to `dev-0` in the [mission control comment](/docs/tips/using-mission-control#override-uuid).\n\n### Step 7: Enable Tracking\n\n```sql\nUPDATE builds\nSET "trackDefaultBranches" = true, "isStatic" = true\nWHERE uuid = \'dev-0\';\n```\n\n## Key Behaviors\n\n| Behavior | Description |\n|----------|-------------|\n| **Fallback resolution** | Ephemeral environments use `dev-0` for services not explicitly built |\n| **Auto-rebuild** | Merges to `main` trigger automatic rebuild and redeploy |\n| **No TTL cleanup** | `isStatic = true` prevents automatic deletion |\n\n### Manual Rebuild Triggers\n\n- Push commit to static environment branch\n- Edit mission control comment\n- Toggle service checkboxes\n\n### Additional Static Environments\n\nCreate multiple static environments with unique UUIDs:\n- `staging-0` - staging services\n- `integration-0` - integration testing\n- `demo-0` - demonstrations\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| Services not updating on merge | Verify `trackDefaultBranches = true` and GitHub App is installed |\n| UUID conflict | Delete old `dev-0` record; check for soft-deleted records |\n| Branch mismatch | Ensure config branch name matches repository default branch |\n\n## Checklist\n\n- [ ] Deleted bootstrap `dev-0` record\n- [ ] Created `lifecycle-static-env` repository\n- [ ] Installed Lifecycle GitHub App\n- [ ] Created PR with `lifecycle.yaml` from `dev-0` branch\n- [ ] Added `lifecycle-deploy!` label\n- [ ] Set UUID to `dev-0` in mission control\n- [ ] Enabled `trackDefaultBranches` and `isStatic` flags',
  },
  {
    title: "Configure environment",
    description: null,
    date: null,
    path: "docs/getting-started/configure-environment",
    body: 'Learn how to customize your Lifecycle environment by configuring services and dependencies.\n\n## Quick Reference\n\n| Option | Purpose | Default |\n|--------|---------|---------|\n| `autoDeploy` | Auto-deploy on PR open/update | `true` |\n| `defaultServices` | Always built and deployed | Required |\n| `optionalServices` | Built on demand only | Falls back to static env |\n| `defaultUUID` | Static environment fallback | `dev-0` |\n| `requires` | Service dependencies | None |\n\n## Configuration File Structure\n\ntrue/false"]\n    defaultServices["defaultServicesAlways deployed"]\n    optionalServices["optionalServicesOn-demand only"]\n    services["services[]"]\n    name["name"]\n    defaultUUID["defaultUUIDFallback static env"]\n    requires["requires[]Dependencies"]\n    github["github"]\n    docker["docker"]\n    dockerEnv["envTemplate variables"]\n\n    root --> env\n    root --> services\n    env --> autoDeploy\n    env --> defaultServices\n    env --> optionalServices\n    services --> name\n    services --> defaultUUID\n    services --> requires\n    services --> github\n    github --> docker\n    docker --> dockerEnv\n`} />\n\n### Example Configuration\n\n```yaml filename="lifecycle.yaml"\nenvironment:\n  autoDeploy: true\n  defaultServices:\n    - name: "frontend"\n    - name: "backend"\n  optionalServices:\n    - name: "cache"\n\nservices:\n  - name: "frontend"\n    defaultUUID: "dev-0"\n    github:\n      repository: "iceycake/lifecycle-examples"\n      branchName: "main"\n      docker:\n        builder:\n          engine: "buildkit"\n        defaultTag: "main"\n        app:\n          dockerfilePath: "Dockerfile.frontend"\n          ports:\n            - 3000\n          env:\n            API_URL: "https://{{{backend_publicUrl}}}"\n            CACHE_URL: "{{{cache_internalHostname}}}"\n  - name: "backend"\n    requires:\n      - name: "db"\n    defaultUUID: "dev-0"\n    # ...\n```\n\n## Service Types\n\n| Type | Behavior | Use Case |\n|------|----------|----------|\n| **Default** | Always built and deployed | Core services (frontend, backend) |\n| **Optional** | Built only when selected | Non-critical services (cache, monitoring) |\n\n**Optional services** use a static environment (`dev-0`) as fallback when not explicitly enabled.\n\n## Template Variables\n\nTemplate variables are dynamically resolved at build and deploy time:\n\n```yaml\nenv:\n  API_URL: "https://{{{backend_publicUrl}}}"\n  CACHE_URL: "{{{cache_internalHostname}}}"\n```\n\n**Resulting values:**\n\n| Variable | When Optional NOT Selected | When Optional Selected |\n|----------|---------------------------|------------------------|\n| `API_URL` | `https://backend-.` | `https://backend-.` |\n| `CACHE_URL` | `cache-dev-0.env-dev-0.svc.cluster.local` | `cache-.env-.svc.cluster.local` |\n\n\n  See all supported template variables in the [Template Variables guide](/docs/features/template-variables).\n\n\n## Auto Deploy\n\n| Setting | Behavior |\n|---------|----------|\n| `autoDeploy: true` | Builds trigger automatically on PR open/update |\n| `autoDeploy: false` | Requires `lifecycle-deploy!` label to trigger |\n\n## Service Dependencies\n\nUse `requires` to declare dependencies:\n\n```yaml\nservices:\n  - name: "backend"\n    requires:\n      - name: "db"\n```\n\nLifecycle automatically:\n1. Resolves the dependency graph\n2. Builds services in correct order\n3. Ensures dependencies are running before dependents start\n\n## Enable Optional Services\n\nTo enable an optional service (e.g., `cache`):\n\n1. Go to the **Lifecycle PR comment** on GitHub\n2. Check the service checkbox\n3. Wait for build to complete\n\nVerify by checking your app\'s Variables page - the URL should now include your environment UUID instead of `dev-0`.\n\n\n  Learn more about the PR interface in [Using Mission Control](/docs/tips/using-mission-control).\n\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| Optional service using static env | Enable service checkbox in PR comment |\n| Deployment not triggering | Check `autoDeploy` setting or add `lifecycle-deploy!` label |\n| Service failing to start | Verify all `requires` dependencies are enabled |\n| Wrong template variable value | Confirm service is enabled and built successfully |\n\n## Checklist\n\n- [ ] `defaultServices` includes all core services\n- [ ] `optionalServices` includes on-demand services\n- [ ] `autoDeploy` set according to team workflow\n- [ ] `defaultUUID` configured for static fallback\n- [ ] `requires` defined for services with dependencies\n- [ ] Template variables use correct syntax: `{{{service_variable}}}`',
  },
  {
    title: "Explore environment",
    description: null,
    date: null,
    path: "docs/getting-started/explore-environment",
    body: "## Quick Reference\n\n| Component | Purpose | Access |\n|-----------|---------|--------|\n| **Mission Control** | Manage services, trigger redeploys | PR comment (pinned) |\n| **Status Comment** | Real-time build/deploy progress | Add `lifecycle-status-comments!` label |\n| **Service URLs** | Access deployed services | Links in PR comments |\n| **Logs** | Debug build/runtime issues | Status comment or dashboard |\n\n## Test Your Application\n\n1. Click the `frontend` link in the PR comment\n2. Add/complete tasks to verify backend connectivity\n3. Visit the `variables` page to inspect container environment\n4. Confirm everything works as expected\n\n## Mission Control Comment\n\nThe PR comment is your **command center** for the ephemeral environment.\n\n\n\n### Available Actions\n\n| Control | Function |\n|---------|----------|\n| Service checkboxes | Enable/disable services in your environment |\n| Redeploy checkbox | Reset environment or recover from transient issues |\n| Deployment links | Direct URLs to running services |\n\n}>\n  See [Mission Control guide](/docs/tips/using-mission-control.mdx) for advanced usage.\n\n\n## Status Comment\n\nAdd the `lifecycle-status-comments!` label to enable real-time deployment updates.\n\n\n\n**Features:**\n- Live status updates for each service\n- Build log links\n- Deployment progress tracking\n\n\n\n## Deploy Status Reference\n\n queued --> cloning --> building --> built --> deploying --> ready\n    cloning --> error\n    building --> build_failed\n    deploying --> deploy_failed\n`} />\n\n| Status | Meaning |\n|--------|---------|\n| `pending` | Waiting to be processed |\n| `queued` | In deployment queue |\n| `cloning` | Fetching source code |\n| `building` | Building Docker image |\n| `built` | Image built successfully |\n| `deploying` | Rolling out to Kubernetes |\n| `ready` | Healthy and serving traffic |\n| `waiting` | Waiting for dependencies |\n| `build_failed` | Docker build error |\n| `deploy_failed` | Kubernetes deployment error |\n| `error` | Unexpected failure |\n| `torn_down` | Service removed |\n\n## Viewing Logs\n\nAccess logs from the status comment or Lifecycle dashboard.\n\n| Log Type | Shows |\n|----------|-------|\n| **Build logs** | Dockerfile execution, dependency installation, build errors |\n| **Container logs** | Application startup, runtime errors, request handling |\n\n## Dashboard Integration\n\nWhen configured, your environment includes links to:\n- **Datadog Logs** - Centralized logging\n- **Fastly Dashboard** - CDN config (if enabled)\n- **Custom Dashboards** - Organization-specific telemetry\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| Service stuck in `building` | Check build logs for errors |\n| `build_failed` status | Review Dockerfile and dependencies |\n| `deploy_failed` status | Check resource limits and health checks |\n| Service not appearing | Verify checkbox is selected in Mission Control |\n| Stale environment | Check the Redeploy checkbox |\n\n## Summary Checklist\n\n- [ ] Accessed frontend via PR comment link\n- [ ] Tested application functionality\n- [ ] Reviewed Mission Control options\n- [ ] Enabled status comments (optional)\n- [ ] Understand deploy status flow\n\n## Next Steps\n\nContinue to customize your configuration and enable optional services like `cache`.",
  },
  {
    title: "Create environment",
    description: null,
    date: null,
    path: "docs/getting-started/create-environment",
    body: '## Quick Reference\n\nCreate your first ephemeral environment in 5 steps:\n\n1. **Fork** the `lifecycle-examples` repository\n2. **Install** your GitHub App on the forked repo\n3. **Update** `lifecycle.yaml` with your GitHub username\n4. **Open PR** from a new branch to `main`\n5. **Wait** for Lifecycle to deploy (check PR comment for status)\n\n**Time to complete**: ~10 minutes\n\n---\n\n## Prerequisites\n\nBefore starting, ensure you have:\n\n- Lifecycle installed and running in your Kubernetes cluster ([Setup Guide](/docs/setup/install-lifecycle))\n- A GitHub App configured for Lifecycle ([Create GitHub App](/docs/setup/create-github-app))\n- Git CLI installed locally\n\n---\n\n## Step-by-Step Instructions\n\n\n\n### Fork and Configure the Repository\n\nFork the [`lifecycle-examples`](https://github.com/GoodRxOSS/lifecycle-examples) repository to your GitHub account or organization.\n\nThen install your Lifecycle GitHub App on the forked repository:\n\n1. Navigate to your GitHub Apps settings:\n   - **Personal account**: `https://github.com/settings/apps`\n   - **Organization**: `https://github.com/organizations//settings/apps`\n2. Find your **Lifecycle GitHub App** and click **Edit**\n3. Select **Install App** from the sidebar\n4. Click the  Settings icon next to your account\n5. Select your forked `lifecycle-examples` repository\n6. Click **Save**\n\n### Create a Branch and Update Configuration\n\nClone your forked repository and create a new branch:\n\n```sh\ngit clone https://github.com//lifecycle-examples.git\ncd lifecycle-examples\ngit checkout -b lfc-config\n```\n\nOpen `lifecycle.yaml` and update the repository path to match your fork:\n\n```yaml filename="lifecycle.yaml"\n# Change this line:\ngithub:\n  repository: "GoodRxOSS/lifecycle-examples"\n\n# To this (replace with your username or org):\ngithub:\n  repository: "/lifecycle-examples"\n```\n\n### Commit and Push\n\n```sh\ngit add lifecycle.yaml\ngit commit -m "Update repository to forked location"\ngit push origin lfc-config\n```\n\n### Open a Pull Request\n\n1. Go to your forked repository on GitHub\n2. Click **Compare & pull request** (or create a new PR from `lfc-config` to `main`)\n3. Submit the pull request\n\n### Monitor Deployment\n\nAfter opening the PR, Lifecycle posts a comment that serves as your **mission control**:\n\n```\n+--------------------------------------------------+\n|  Lifecycle Environment Status                     |\n+--------------------------------------------------+\n|  Status: deploying                               |\n|  Services: frontend                              |\n|  Dashboard: [link]                               |\n+--------------------------------------------------+\n```\n\nThe comment provides:\n- **Build/deploy status** - Current state of your environment\n- **Service list** - All configured services\n- **Dashboard link** - Access logs, deployments, and details\n\n\n  **Auto-deploy enabled?** If `autoDeploy: true` in your `lifecycle.yaml`, deployment starts automatically when you open the PR.\n\n  **Auto-deploy disabled?** Add the `lifecycle-deploy!` label to your PR to trigger deployment.\n\n\n**Optional**: Add the `lifecycle-status-comments!` label for detailed status updates including environment URLs and telemetry links.\n\n\n\n---\n\n## Environment States\n\nTrack your environment through these build statuses:\n\n| Status | Description |\n|--------|-------------|\n| `queued` | Build waiting to be processed |\n| `pending` | Build being prepared |\n| `building` | Docker images being built |\n| `built` | All images built successfully |\n| `deploying` | Services deploying to Kubernetes |\n| `deployed` | Environment live and accessible |\n| `error` | Build or deploy failed |\n| `config_error` | Invalid `lifecycle.yaml` configuration |\n\n---\n\n## Access Your Application\n\nOnce status shows `deployed`, click the **frontend** link in the Lifecycle PR comment to open your application.\n\nThe example application includes two pages:\n\n| Page | Description |\n|------|-------------|\n| `/tasks` | Simple to-do list demo |\n| `/variables` | Displays container environment variables |\n\n---\n\n## Troubleshooting\n\n### No Lifecycle comment on PR\n\n**Problem**: No comment appears after opening the pull request.\n\n**Solution**: The GitHub App may not be configured correctly.\n- Verify the app is installed on the repository\n- Check webhook delivery in GitHub App settings\n- See [Missing Comment Troubleshooting](/docs/troubleshooting/github-app-webhooks)\n\n### Build or deploy errors\n\n**Problem**: Status shows `error` and environment is not created.\n\n**Solution**: Check the worker logs for details:\n\n```sh\nkubectl logs deploy/lifecycle-worker -n lifecycle-app -f\n```\n\nCommon causes:\n- Invalid Dockerfile or build configuration\n- Missing environment variables\n- Resource constraints in the cluster\n\n### Environment stuck in `pending` or `building`\n\n**Problem**: Status does not progress past initial states.\n\n**Solution**:\n- Verify your Kubernetes cluster has available resources\n- Check that the Lifecycle worker pods are running\n- Review worker logs for queue processing issues\n\n---\n\n## What Happens on New Commits?\n\nWhen you push new commits to your PR branch, Lifecycle automatically:\n\n1. Detects the change via GitHub webhook\n2. Rebuilds affected Docker images\n3. Redeploys updated services\n4. Updates the PR comment with new status\n\nYour environment always reflects the latest code in your PR.\n\n---\n\n## Next Steps\n\nYour first ephemeral environment is running. Continue to:\n\n- [Explore Environment](/docs/getting-started/explore-environment) - View logs, test services, and navigate the dashboard\n- [Configure Environment](/docs/getting-started/configure-environment) - Customize your `lifecycle.yaml` configuration\n- [Delete Environment](/docs/getting-started/delete-environment) - Clean up when you are done',
  },
  {
    title: "Delete environment",
    description: null,
    date: null,
    path: "docs/getting-started/delete-environment",
    body: '## Quick Reference\n\n| Action | Method | Result |\n|--------|--------|--------|\n| Delete now | Add `lifecycle-disabled!` label | Immediate teardown |\n| Delete on merge | Merge/close PR | Auto cleanup |\n| Remove manual deploy | Remove `lifecycle-deploy!` label | Triggers deletion |\n| Prevent auto-cleanup | Add `lifecycle-keep!` label | Exempts from TTL |\n| Redeploy | Remove `lifecycle-disabled!`, add `lifecycle-deploy!` | New environment |\n\n## Deletion Flow\n\n tearing\n    subgraph tearing["Status: tearing_down"]\n        T1["Removes deployments, services, pods, ingress"]\n        T2["Deletes env-uuid namespace"]\n        T3["Removes Helm releases"]\n    end\n    tearing --> torn\n    subgraph torn["Status: torn_down"]\n        D1["Environment fully deleted"]\n    end\n`} />\n\n## Manual Deletion\n\n### Merge or Close the PR\n\nClosing the PR automatically triggers cleanup of all deployed services, namespace, and resources.\n\n### Add `lifecycle-disabled!` Label\n\nUse when:\n- Environment has infrastructure issues\n- Data is corrupt\n- Need a fresh rebuild without closing PR\n\n### Remove `lifecycle-deploy!` Label\n\nOnly applies when `autoDeploy` is disabled. See [auto-deployment](/docs/features/auto-deployment).\n\n## Automatic TTL Cleanup\n\n| Setting | Default |\n|---------|---------|\n| Inactivity period | 14 days |\n| Check interval | 4 hours |\n\nWhen TTL expires, Lifecycle:\n1. Posts cleanup comment on PR\n2. Adds `lifecycle-disabled!` label\n3. Removes `lifecycle-deploy!` label\n4. Tears down environment\n\n\n  Add the `lifecycle-keep!` label to prevent TTL cleanup for long-running or demo environments.\n\n\n## What Gets Deleted vs Preserved\n\n| Deleted | Preserved |\n|---------|-----------|\n| Kubernetes resources (pods, services, ingress) | Static environments (e.g., `dev-0`) |\n| `env-` namespace | PR history in GitHub |\n| Helm releases | Build records in database |\n| Container images (per registry policy) | |\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| Environment won\'t delete | Check for `lifecycle-keep!` label and remove it |\n| Accidental deletion | Remove `lifecycle-disabled!`, add `lifecycle-deploy!` to redeploy |\n| TTL deleted my environment | Add `lifecycle-keep!` label before next deploy |\n| Need fresh environment | Add `lifecycle-disabled!`, wait for teardown, then add `lifecycle-deploy!` |\n\n\n  Redeployed environments get a new UUID. Previous environment data is not restored.\n\n\n## Checklist\n\n- [ ] Decide deletion method: manual (label/PR close) or wait for TTL\n- [ ] For long-running environments, add `lifecycle-keep!` to prevent auto-cleanup\n- [ ] To redeploy: remove `lifecycle-disabled!`, add `lifecycle-deploy!`\n- [ ] Verify status shows `torn_down` after deletion completes',
  },
  {
    title: "Telemetry & Observability",
    description:
      "Monitor your Lifecycle environments with logging, tracing, and metrics",
    date: "2025-01-29",
    path: "docs/tips/telemetry",
    body: '## Quick Reference\n\n| Feature | Tool | Key Variable | Filter Query |\n|---------|------|--------------|--------------|\n| Logging | Pino | `LOG_LEVEL=info` | `buildUuid:{uuid}` |\n| Tracing | Datadog APM | `DD_TRACE_ENABLED=true` | `env:lifecycle-{buildUUID}` |\n| Metrics | StatsD | - | `lifecycle.{category}.{metric}` |\n\n\n\n---\n\n## Datadog Integration\n\nLifecycle automatically configures pods with Datadog labels and environment variables.\n\n\nYour application must have a Datadog tracing library installed (dd-trace for Node.js, ddtrace for Python, etc.).\n\n\n### Auto-Injected Configuration\n\n| Pod Label / Env Variable | Value | Purpose |\n|--------------------------|-------|---------|\n| `tags.datadoghq.com/env` / `DD_ENV` | `lifecycle-{buildUUID}` | Environment grouping |\n| `tags.datadoghq.com/service` / `DD_SERVICE` | Service name | Service identification |\n| `tags.datadoghq.com/version` / `DD_VERSION` | Build UUID | Version tracking |\n| `DD_AGENT_HOST` | Agent hostname | Agent location |\n\n**Prerequisite:** Datadog agent must be running in your cluster (install via Helm chart or operator).\n\n---\n\n## Logging\n\n### Configuration Variables\n\n| Variable | Default | Description |\n|----------|---------|-------------|\n| `LOG_LEVEL` | `debug` | `trace` > `debug` > `info` > `warn` > `error` > `fatal` |\n| `PINO_LOGGER` | `true` | Enable/disable logging |\n| `PINO_PRETTY` | `false` | Pretty-print for local dev |\n\n### Log Context Fields\n\n| Field | Description |\n|-------|-------------|\n| `correlationId` | Trace related operations |\n| `buildUuid` | Environment identifier |\n| `deployUuid` | Deployment identifier |\n| `serviceName` | Service name |\n| `stage` | Operation stage |\n| `repo`, `pr`, `branch` | Git context |\n\n### Log Stages by Operation\n\n| Operation | Stages |\n|-----------|--------|\n| Webhook | `received` → `queued` → `processing` → `complete`/`skipped` |\n| Build | `created` → `queued` → `starting` → `image.building` → `image.pushing` → `complete`/`failed` |\n| Deploy | `queued` → `starting` → `helm.installing` → `helm.complete` → `complete`/`failed` |\n| Cleanup | `starting` → `complete`/`failed` |\n\n---\n\n## Distributed Tracing\n\n### Automatic Traces\n\nTraces are created for: API requests, build operations, deployment jobs, database queries, and Redis operations.\n\n### Service Mapping\n\n| Internal | Datadog Service |\n|----------|-----------------|\n| Redis | `lifecycle-redis` |\n| PostgreSQL | `lifecycle-postgres` |\n| Application | `lifecycle-job` |\n\n### Log-Trace Correlation\n\nLogs include `dd.trace_id` and `dd.span_id` for jumping directly from logs to traces in Datadog.\n\n---\n\n## Metrics\n\n### Metric Format\n\n```\nlifecycle.{category}.{metric}\n```\n\n| Type | Example | Description |\n|------|---------|-------------|\n| Increment | `lifecycle.build.started` | Count occurrences |\n| Timing | `lifecycle.deploy.duration` | Measure duration |\n| Event | `lifecycle.environment.created` | Record events |\n\n**Tags:** `env`, `uuid`, `repositoryName`, `branchName`, `sha`\n\n---\n\n## Accessing Data\n\n### Datadog Filters\n\n```bash\n# By environment\nenv:lifecycle-{buildUUID}\n\n# By service\nservice:{serviceName}\n```\n\n### Dashboard Links\n\nThe Lifecycle dashboard provides direct links to: Logs, APM Traces, Container Dashboards, Fastly Logs, and RUM Sessions.\n\n---\n\n## Disabling Telemetry\n\n| Goal | Configuration |\n|------|---------------|\n| Disable tracing | `DD_TRACE_ENABLED: "false"` |\n| Reduce log volume | `LOG_LEVEL: "warn"` |\n| Disable logging | `PINO_LOGGER: "false"` (not recommended) |\n\n---\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| Traces not appearing | 1. Verify Datadog agent is running2. Check `DD_TRACE_ENABLED` is not false3. Confirm tracing library is installed |\n| Logs missing context | 1. Check log level setting2. Verify structured logging is enabled3. Ensure correlationId is passed through requests |\n| Metrics not collected | 1. Verify StatsD endpoint configuration2. Check network connectivity to collector |\n\n---\n\n## Summary Checklist\n\n- [ ] Datadog agent installed in cluster\n- [ ] Application instrumented with Datadog tracing library\n- [ ] `LOG_LEVEL` set appropriately (`info` or `warn` for production)\n- [ ] Use `correlationId` and `buildUuid` for debugging\n- [ ] Check `stage` field to identify where failures occur\n- [ ] Configure alerts on error metrics\n- [ ] Use APM traces for performance bottlenecks',
  },
  {
    title: "Mission Control Comment",
    description: "Understanding and using the Lifecycle PR comment interface",
    date: "2025-01-29",
    path: "docs/tips/using-mission-control",
    body: '# Mission Control\n\nMission Control is the PR comment interface for monitoring and managing ephemeral environments directly from GitHub.\n\n## Quick Reference\n\n| What You Want | How To Do It |\n|---------------|--------------|\n| Deploy environment | Add `lifecycle-deploy!` label to PR |\n| Enable status comments | Add `lifecycle-status-comments!` label |\n| Disable a service | Uncheck its checkbox in the comment |\n| Change service branch | Edit the branch name in parentheses |\n| Set env variable | Add `ENV:KEY:value` line |\n| Custom URL | Add `url: my-subdomain` line |\n| Redeploy everything | Check `[ ] Redeploy Environment` |\n\n---\n\n## Comment Types\n\n\n\n---\n\n## Environment Status\n\n| Status | Meaning |\n|--------|---------|\n| **is pending** | Waiting to process or torn down |\n| **is building** | Docker images being created |\n| **is deploying** | Services deploying to Kubernetes |\n| **is ready to deploy** | Built, waiting for deploy label |\n| **is deployed** | All services live and accessible |\n| **deployed with an Error** | Some services failed |\n| **has a configuration error** | Invalid `lifecycle.yaml` |\n\n## Service Status\n\n| Status | Meaning |\n|--------|---------|\n| **Queued** | Waiting to be processed |\n| **Cloning** | Source code being fetched |\n| **Building** | Docker image building |\n| **Built** | Image ready |\n| **Waiting** | Waiting for dependencies |\n| **Deploying** | Rolling out to cluster |\n| **Ready** | Live and healthy |\n| **Build Failed** | Docker build error |\n| **Deploy Failed** | Kubernetes deployment error |\n\n---\n\n## Configuring Services\n\n### Enable/Disable Services\n\n```\n[x] api-service (main)      ← Enabled\n[x] database                ← Enabled\n[ ] redis-cache             ← Disabled (won\'t deploy)\n```\n\n### Change Branch\n\n```diff\n- [x] api-service (main)\n+ [x] api-service (feature-branch)\n```\n\n### Set Environment Variables\n\n```\nENV:API_KEY:my-secret-value\nENV:DEBUG:true\nENV:LOG_LEVEL:verbose\n```\n\n### Custom URL\n\n```\nurl: my-feature\n```\n\nResult: `my-feature.lifecycle.example.com`\n\n---\n\n## Actions\n\n| Action | Effect |\n|--------|--------|\n| `[ ] Redeploy Environment` | Tear down and rebuild all services |\n| `[ ] Purge Fastly Service Cache` | Clear CDN cache (if using Fastly) |\n| `[ ] Redeploy on pushes to default branches` | Auto-sync with main/master updates |\n\n\nRedeploy tears down the entire environment first. Save any ephemeral data before triggering.\n\n\n---\n\n## Common Mistakes\n\n### WRONG: Editing without submitting\n\n```\n[ ] Redeploy Environment   ← Checked but not submitted\n```\n\n**CORRECT:** After checking a box, click "Update comment" to trigger the action.\n\n### WRONG: Setting env vars with spaces\n\n```\nENV:MY_VAR: some value     ← Space after colon breaks parsing\n```\n\n**CORRECT:**\n\n```\nENV:MY_VAR:some value      ← No space after second colon\n```\n\n### WRONG: Expecting disabled service URLs\n\n```\n[ ] redis-cache            ← Disabled service has no URL\n```\n\n**CORRECT:** Only enabled services with `public: true` get accessible URLs.\n\n---\n\n## Example Comment\n\n```\n## Lifecycle Environment\n\n**Status:** is deployed\n\n### Services\n\n| Service  | Status | URL                                      |\n|----------|--------|------------------------------------------|\n| api      | Ready  | https://api-abc123.lifecycle.example.com |\n| web      | Ready  | https://web-abc123.lifecycle.example.com |\n| database | Ready  | (internal only)                          |\n\n### Configuration\n\n[x] api (main)\n[x] web (main)\n[x] database\n\nENV:DEBUG:false\n\nurl: abc123\n\n### Actions\n\n[ ] Redeploy Environment\n[ ] Purge Fastly Service Cache\n```\n\n---\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| Comment not appearing | Verify `lifecycle-deploy!` label is on PR |\n| Comment not updating | Refresh page (GitHub caches); check webhook config |\n| Action checkbox not working | Submit the comment after checking; verify environment state allows action |\n| Service URL not accessible | Confirm status is "Ready" and service has `public: true` |\n| Status comment missing | Add `lifecycle-status-comments!` label to PR |\n\n---\n\n## Summary\n\n| Task | Action |\n|------|--------|\n| Monitor environment | Check Mission Control comment header |\n| Debug failed service | Look for "Build Failed" or "Deploy Failed" status |\n| Test different branch | Edit branch name in service checkbox line |\n| Share environment | Copy URL from Services table or set custom `url:` |\n| Fresh start | Check "Redeploy Environment" and submit |\n| Stay synced with main | Check "Redeploy on pushes to default branches" |',
  },
];

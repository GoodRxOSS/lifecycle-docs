---
title: Service Dependencies
description: Configure which services deploy together and in what order
tags:
  - dependencies
  - requires
  - deploymentDependsOn
  - deployment-order
date: "2025-01-29"
---

import { Callout } from "nextra/components";
import { Mermaid } from "@lifecycle-docs/components";

## Quick Reference

Lifecycle has two dependency fields that serve different purposes:

| Field                 | What it does                         | When to use                                |
| --------------------- | ------------------------------------ | ------------------------------------------ |
| `requires`            | Includes services in the environment | "I need this service to exist"             |
| `deploymentDependsOn` | Controls deployment order            | "Wait for this service before starting me" |

<Callout type="info">
  **Most common pattern:** Use both fields together when your service needs
  another service to be running before it can start.
</Callout>

```yaml
services:
  - name: "api"
    requires:
      - name: "database" # Include database in environment
    deploymentDependsOn:
      - "database" # Wait for database before deploying
```

---

## Understanding the Difference

### `requires` = Environment Composition

The `requires` field answers: **"What services must exist for this service to function?"**

- Adds services to the environment automatically
- Does NOT control when services deploy
- Follows the service everywhere (PRs, static environments, cross-repo references)

### `deploymentDependsOn` = Deployment Order

The `deploymentDependsOn` field answers: **"What services must be running before this service starts?"**

- Controls the order services deploy
- Does NOT add services to the environment
- Only affects deployment timing

### Why You Often Need Both

```yaml
# WRONG - database may not be ready when api starts
services:
  - name: "api"
    requires:
      - name: "database"    # Database is included, but...
    # ...api might deploy before database is ready!

# CORRECT - database is included AND api waits for it
services:
  - name: "api"
    requires:
      - name: "database"    # Include database
    deploymentDependsOn:
      - "database"          # Wait for database
```

---

## The `requires` Field

### Basic Syntax

```yaml
services:
  - name: "api"
    requires:
      - name: "database"
      - name: "cache"
```

When `api` is deployed, `database` and `cache` are automatically included.

### Cross-Repository References

```yaml
requires:
  - name: "shared-auth"
    repository: "myorg/auth-service"
    branch: "main"
```

<Callout type="warning">
  **One-level limit:** External repository dependencies only resolve one level
  deep.
</Callout>

**What this means:**

<Mermaid
  chart={`
flowchart LR
    subgraph YourRepo["Your Repo"]
        api
    end
    subgraph ExternalRepo["External Repo"]
        auth
        redis
    end
    api -->|requires| auth
    auth -.->|requires| redis
    auth -.-|included| api
    redis -.-|NOT included| api
`}
/>

If `auth` requires `redis`, you must explicitly add `redis` to your configuration:

```yaml
requires:
  - name: "auth"
    repository: "myorg/auth-service"
    branch: "main"
  - name: "redis" # Explicitly add transitive dependency
    repository: "myorg/auth-service"
    branch: "main"
```

---

## The `deploymentDependsOn` Field

### Basic Syntax

```yaml
services:
  - name: "api"
    deploymentDependsOn:
      - "database"
      - "cache"
```

The `api` service waits for `database` and `cache` to be ready before deploying.

### How Deployment Order Works

Lifecycle deploys services in levels:

1. **Level 0:** Services with no dependencies (deploy in parallel)
2. **Level 1:** Services depending only on Level 0 (deploy in parallel)
3. **Level 2:** Services depending on Level 0 or 1 (deploy in parallel)
4. And so on...

**Example:**

```yaml
services:
  - name: "database" # Level 0

  - name: "cache" # Level 0

  - name: "api" # Level 1
    deploymentDependsOn:
      - "database"
      - "cache"

  - name: "worker" # Level 1
    deploymentDependsOn:
      - "database"

  - name: "frontend" # Level 2
    deploymentDependsOn:
      - "api"
```

**Deployment timeline:**

<Mermaid
  chart={`
flowchart TB
    subgraph Level0["Level 0 (deploy in parallel)"]
        database
        cache
    end
    subgraph Level1["Level 1 (deploy in parallel after Level 0)"]
        api
        worker
    end
    subgraph Level2["Level 2 (deploys after Level 1)"]
        frontend
    end
    Level0 --> Level1
    Level1 --> Level2
`}
/>

### Edge Cases

- **Self-references:** Automatically ignored
- **Missing services:** References to services not in the environment are ignored
- **Circular dependencies:** Affected services won't deploy (no error thrown)

---

## Common Patterns

### Pattern 1: Database with Migrations

```yaml
services:
  - name: "database"
    docker:
      dockerImage: "postgres"
      defaultTag: "15"

  - name: "migrations"
    deploymentDependsOn:
      - "database"
    # Runs after database is ready

  - name: "api"
    requires:
      - name: "database"
    deploymentDependsOn:
      - "migrations"
    # Runs after migrations complete
```

### Pattern 2: Frontend with Backend

```yaml
services:
  - name: "backend"
    requires:
      - name: "database"
      - name: "cache"
    deploymentDependsOn:
      - "database"
      - "cache"

  - name: "frontend"
    deploymentDependsOn:
      - "backend"
    # Frontend waits for backend, but doesn't "require" it
    # (frontend can run without backend for static content)
```

### Pattern 3: Cross-Repository Service

```yaml
environment:
  defaultServices:
    - name: "my-app"
    - name: "shared-api"
      repository: "myorg/shared-api"
      branch: "main"
    - name: "shared-database" # Explicitly include transitive deps
      repository: "myorg/shared-api"
      branch: "main"

services:
  - name: "my-app"
    deploymentDependsOn:
      - "shared-api"
```

---

## Environment Configuration

### Default Services

Services that always deploy with the environment:

```yaml
environment:
  defaultServices:
    - name: "api"
    - name: "database"
```

### Optional Services

Services that can be toggled on/off via Mission Control:

```yaml
environment:
  optionalServices:
    - name: "debug-tools"
    - name: "monitoring"
```

---

## Troubleshooting

### Service not deploying

1. Is it in `defaultServices`, `optionalServices`, or another service's `requires`?
2. For external repos: Did you include transitive dependencies explicitly?
3. Check for typos in service names

### Service deploys before its dependency is ready

Add the dependency to `deploymentDependsOn`, not just `requires`:

```yaml
# Add this:
deploymentDependsOn:
  - "database"
```

### External service missing its dependencies

The one-level limit means you must explicitly include transitive dependencies:

```yaml
environment:
  defaultServices:
    - name: "external-api"
      repository: "myorg/external"
      branch: "main"
    - name: "external-database" # Add this explicitly
      repository: "myorg/external"
      branch: "main"
```

---

## Summary

| Question                                  | Answer               | Field                              |
| ----------------------------------------- | -------------------- | ---------------------------------- |
| "What services do I need?"                | List them            | `requires`                         |
| "What order should services deploy?"      | Specify dependencies | `deploymentDependsOn`              |
| "I need service X running before I start" | Use both             | `requires` + `deploymentDependsOn` |

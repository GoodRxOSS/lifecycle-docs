---
title: Native Helm Deployment
description: Deploy services using Helm directly in Kubernetes without external CI/CD dependencies
tags:
  - helm
  - deployment
  - kubernetes
  - native
date: "2025-01-29"
---

import { Callout, Steps } from "nextra/components";
import { Image, Mermaid } from "@lifecycle-docs/components";

<Callout type="warning">
  This feature is in active development. Review the changelog for breaking
  changes before upgrading.
</Callout>

## Quick Reference

| Aspect                 | Details                                                             |
| ---------------------- | ------------------------------------------------------------------- |
| **What it does**       | Runs Helm deployments as Kubernetes jobs (no external CI/CD needed) |
| **Enable globally**    | `helm.nativeHelm.enabled: true` in lifecycle.yaml                   |
| **Enable per-service** | `helm.deploymentMethod: "native"`                                   |
| **Chart types**        | ORG_CHART, LOCAL (`./`), PUBLIC (external registries)               |
| **Job timeout**        | 30 minutes (configurable)                                           |
| **Template syntax**    | `{{{variable}}}` (triple braces)                                    |

## Quickstart

```yaml filename="lifecycle.yaml"
services:
  - name: my-api
    helm:
      deploymentMethod: "native"
      chart:
        name: "local"
        valueFiles:
          - "./helm/values.yaml"
```

This creates a Kubernetes job that runs `helm upgrade --install` for your service.

## How It Works

<Mermaid
  chart={`
flowchart LR
    subgraph Setup
        A[1. K8s Job Created] --> B[2. Service Account / RBAC Setup]
        B --> C[3. Init Container / Git Clone]
    end
    subgraph Deployment
        C --> D[4. helm-deploy Container]
        D --> E[helm upgrade --install]
    end
    subgraph Monitoring
        D --> F[5. WebSocket Streaming]
        F --> G[Monitor Logs]
    end
`}
/>

## Configuration

### Enable Native Helm

**Per-service:**

```yaml filename="lifecycle.yaml"
services:
  - name: my-service
    helm:
      deploymentMethod: "native"
      chart:
        name: my-chart
```

**Global (all services):**

```yaml filename="lifecycle.yaml"
helm:
  nativeHelm:
    enabled: true
```

<Callout type="info">
  Service-level `deploymentMethod` overrides global settings. Use
  `deploymentMethod: "ci"` to force CI/CD for specific services.
</Callout>

### Configuration Precedence

<Mermaid
  chart={`
flowchart LR
    A["helmDefaults<br/>(database)<br/><i>Lowest Priority</i>"] --> B["Chart-specific config<br/>(database)"]
    B --> C["Service YAML<br/>(lifecycle.yaml)<br/><i>Highest Priority</i>"]
`}
/>

### Chart Types

| Type          | Detection                                      | Use Case                        |
| ------------- | ---------------------------------------------- | ------------------------------- |
| **ORG_CHART** | Matches `orgChartName` + has `helm.docker`     | Internal organization charts    |
| **LOCAL**     | Name is `"local"` or starts with `./` or `../` | Charts in your repo             |
| **PUBLIC**    | Everything else                                | External charts (Bitnami, etc.) |

**PUBLIC charts** skip git clone and build phases unless `valueFiles` reference repo files.

## Common Patterns

### Deploy a Public Chart (Jenkins)

```yaml filename="lifecycle.yaml"
services:
  - name: "jenkins"
    helm:
      chart:
        name: "jenkins"
        repoUrl: "https://charts.bitnami.com/bitnami"
        version: "13.6.8"
        values:
          - "service.type=ClusterIP"
          - "ingress.enabled=true"
          - "ingress.hostname={{{jenkins_publicUrl}}}"
```

No repository or branch needed for public charts.

### Local Chart with Custom Values

```yaml filename="lifecycle.yaml"
services:
  - name: web-api
    helm:
      deploymentMethod: "native"
      repository: "myorg/apps"
      branchName: "main"
      chart:
        name: "./charts/app"
        values:
          - "image.tag={{{web-api_dockerTag}}}"
        valueFiles:
          - "deploy/helm/values.yaml"
      docker:
        app:
          dockerfilePath: "Dockerfile"
```

### Public Chart with Repo Value Files

```yaml filename="lifecycle.yaml"
services:
  - name: "postgres-db"
    helm:
      repository: "myorg/my-repo"
      branchName: "main"
      chart:
        name: "postgresql"
        repoUrl: "https://charts.bitnami.com/bitnami"
        version: "12.9.0"
        valueFiles:
          - "deploy/helm/db-values.yaml"
```

## Template Variables

Use `{{{variable}}}` syntax (triple braces). Lifecycle resolves these before passing to Helm.

| Variable                             | Example Value                            |
| ------------------------------------ | ---------------------------------------- |
| `{{{serviceName_dockerTag}}}`        | `main-abc123`                            |
| `{{{serviceName_dockerImage}}}`      | `registry.com/org/repo:main-abc123`      |
| `{{{serviceName_internalHostname}}}` | `api-service.env-uuid.svc.cluster.local` |
| `{{{build.uuid}}}`                   | `env-12345`                              |
| `{{{build.namespace}}}`              | `env-12345`                              |

**Example:**

```yaml
values:
  - "image.tag={{{web-api_dockerTag}}}"
  - "backend.url=http://{{{backend-service_internalHostname}}}:8080"
```

## Environment Variable Mapping

Different charts expect env vars in different formats. Use `envMapping` to adapt.

### WRONG vs CORRECT Placement

```yaml
# WRONG - envMapping under chart
helm:
  chart:
    name: local
    envMapping: # This will NOT work
      app:
        format: "array"
```

```yaml
# CORRECT - envMapping under helm
helm:
  chart:
    name: local
  envMapping: # Correct placement
    app:
      format: "array"
      path: "env"
  docker: # Required for envMapping
    app:
      env:
        MY_VAR: "value"
```

### Array Format

For charts expecting Kubernetes-style env arrays:

```yaml filename="lifecycle.yaml"
helm:
  envMapping:
    app:
      format: "array"
      path: "env"
  docker:
    app:
      env:
        DATABASE_URL: "postgres://localhost:5432/mydb"
        API_KEY: "secret"
```

**Produces:**

```bash
--set env[0].name=DATABASE_URL --set env[0].value=postgres://localhost:5432/mydb
--set env[1].name=API_KEY --set env[1].value=secret
```

### Map Format

For charts expecting key-value objects:

```yaml filename="lifecycle.yaml"
helm:
  envMapping:
    app:
      format: "map"
      path: "envVars"
  docker:
    app:
      env:
        DATABASE_URL: "postgres://localhost:5432/mydb"
```

**Produces:**

```bash
--set envVars.DATABASE__URL="postgres://localhost:5432/mydb"
```

<Callout type="warning">
  Underscores become double underscores (`__`) in map format to avoid Helm
  parsing issues.
</Callout>

## Global Configuration (Database)

Store defaults in the `global_config` table.

### helmDefaults

```json
{
  "version": "3.12.0",
  "nativeHelm": {
    "enabled": true,
    "defaultArgs": "--wait --timeout 30m"
  }
}
```

### Chart-specific (e.g., key: "postgresql")

```json
{
  "version": "3.13.0",
  "args": "--force --timeout 60m0s --wait",
  "chart": {
    "name": "postgresql",
    "repoUrl": "https://charts.bitnami.com/bitnami",
    "version": "12.9.0"
  }
}
```

## Monitoring Deployments

1. Add `lifecycle-status-comments!` label to your PR
2. Click **Deploy Logs** in the status comment
3. View real-time logs via WebSocket

The log viewer shows:

- `clone-repo` container (git operations)
- `helm-deploy` container (Helm execution)
- Status indicators (Active, Complete, Failed)

## Troubleshooting

### "Another Operation in Progress"

**Problem:** Helm reports an existing operation is blocking.

**Solution:** Native Helm auto-handles this. If it persists:

```bash
kubectl get jobs -n env-{uuid} -l service={serviceName}
kubectl delete job {jobName} -n env-{uuid} --force --grace-period=0
helm uninstall {releaseName} -n env-{uuid} --no-hooks
```

### Environment Variables Not Working

**Problem:** Env vars not passed to deployment.

**Checklist:**

- [ ] `envMapping` is under `helm:`, not under `chart:`
- [ ] `docker:` section exists with `env:` defined
- [ ] `path` matches your chart's expected structure

### "Helm Version is Required" Error

**Problem:** Missing version in database config.

**Solution:** Add `version` at top level of `helmDefaults`:

```json
{
  "version": "3.12.0",
  "nativeHelm": { "enabled": true }
}
```

### RBAC Permission Issues

**Problem:** Helm deployment fails with permission errors.

**Solution:**

```bash
kubectl get roles,rolebindings -n env-{uuid}
kubectl describe role native-helm-role -n env-{uuid}
```

## Migration from GitHub-type to Helm-type

| Before (GitHub-type) | After (Helm-type)   |
| -------------------- | ------------------- |
| `github.repository`  | `helm.repository`   |
| `github.branchName`  | `helm.branchName`   |
| `github.docker`      | `helm.docker`       |
| `github.deployment`  | `helm.chart.values` |
| `{{var}}`            | `{{{var}}}`         |

**Before:**

```yaml
services:
  - name: "api"
    github:
      repository: "myorg/api"
      docker:
        app:
          env:
            URL: "{{backend_internalHostname}}"
```

**After:**

```yaml
services:
  - name: "api"
    helm:
      deploymentMethod: "native"
      repository: "myorg/api"
      chart:
        name: "./charts/app"
        values:
          - "image.tag={{{api_dockerTag}}}"
      docker:
        app:
          env:
            URL: "{{{backend_internalHostname}}}"
```

## Advanced Configuration

### OCI Registry Charts

```yaml
chart:
  name: "myapp"
  repoUrl: "oci://ghcr.io/myorg/charts/myapp"
  version: "1.2.3"
```

### Built-in Repository Aliases

| Alias                  | URL                                                  |
| ---------------------- | ---------------------------------------------------- |
| `bitnami`              | `https://charts.bitnami.com/bitnami`                 |
| `stable`               | `https://charts.helm.sh/stable`                      |
| `prometheus-community` | `https://prometheus-community.github.io/helm-charts` |
| `grafana`              | `https://grafana.github.io/helm-charts`              |

### Concurrent Deployment Handling

Native Helm uses "newest wins" strategy:

1. Detects existing jobs with same release name
2. Annotates as `superseded-by-retry`
3. Force-deletes existing pods/jobs
4. Deploys new version

### Job Lifecycle

| Environment | Job TTL                   |
| ----------- | ------------------------- |
| Ephemeral   | Cleaned with namespace    |
| Static      | 24 hours after completion |

## Summary

| Task                  | Configuration                               |
| --------------------- | ------------------------------------------- |
| Enable globally       | `helm.nativeHelm.enabled: true`             |
| Enable per-service    | `helm.deploymentMethod: "native"`           |
| Use local chart       | `chart.name: "./path/to/chart"`             |
| Use public chart      | `chart.name: "chartname"` + `chart.repoUrl` |
| Map env vars (array)  | `envMapping.app.format: "array"`            |
| Map env vars (map)    | `envMapping.app.format: "map"`              |
| Override Helm version | `helm.version: "3.14.0"`                    |
| Custom Helm args      | `helm.args: "--atomic --timeout 10m"`       |
| Template variables    | `{{{serviceName_dockerTag}}}`               |

---
title: What is Lifecycle?
description: Lifecycle is your effortless way to test and create ephemeral environments
tags:
  - core
  - lifecycle
  - intro
date: "2025-03-12"
---

import { Image, Mermaid } from "@lifecycle-docs/components";
import Iframe from "@/components/iframe";

# What is Lifecycle?

Lifecycle automatically creates isolated, fully-functional environments for every GitHub pull request. No manual setup, no environment conflicts, no cleanup headaches.

## Quick Reference

| What              | Description                                                 |
| ----------------- | ----------------------------------------------------------- |
| **Purpose**       | Ephemeral environment orchestrator for PR-based development |
| **Trigger**       | Opens a PR on GitHub                                        |
| **Result**        | Isolated Kubernetes namespace with your services deployed   |
| **Configuration** | Single `lifecycle.yaml` file in your repository             |
| **Cleanup**       | Automatic when PR is merged or closed                       |

## How It Works

<Mermaid
  chart={`
flowchart LR
    A[PR Opened] --> B[Lifecycle reads config]
    B --> C[Builds services]
    C --> D[Deploys to isolated namespace]
    D --> E[Shareable URL ready]
    E --> F[User validates]
    F --> G[Environment torn down]
    G --> H[PR Merged]
`}
/>

<Image src="/docs/simple-workflow.png" width={1941} height={1613} />

**The workflow in detail:**

1. Developer opens a PR on GitHub
2. Webhook triggers Lifecycle to read `lifecycle.yaml`
3. Services are built and deployed to a dedicated Kubernetes namespace
4. Shareable URLs are generated and posted to the PR
5. Environment auto-deletes when PR closes

## Key Capabilities

### Deployment Types

| Type             | Use Case                           |
| ---------------- | ---------------------------------- |
| `GITHUB`         | Build and deploy from source code  |
| `DOCKER`         | Deploy pre-built Docker images     |
| `HELM`           | Deploy using Helm charts           |
| `EXTERNAL_HTTP`  | Reference external services        |
| `AURORA_RESTORE` | Clone Aurora databases for testing |

### Built-in Features

- **Multi-service orchestration** - Deploy interconnected services with automatic dependency handling
- **Multi-repo support** - Include services from different repositories in one environment
- **Native builds** - Kubernetes-native building with BuildKit or Kaniko
- **Real-time logs** - Stream build and deployment logs via web UI or API
- **TTL-based cleanup** - Configurable expiration prevents resource waste
- **SPOT instance support** - Minimize infrastructure costs

## Use Cases

| Scenario                | Benefit                                                       |
| ----------------------- | ------------------------------------------------------------- |
| **Feature development** | Isolated environments prevent conflicts between developers    |
| **QA testing**          | Fully connected environments for manual and automated tests   |
| **Design review**       | Live URLs for product managers and designers to interact with |
| **Partner sandboxes**   | Isolated environments sharing only what's necessary           |

## Why Lifecycle?

**Without Lifecycle:**

- Shared dev/staging environments with constant conflicts
- Manual environment setup eating into development time
- Stale test environments consuming resources
- Slow feedback loops waiting for staging deployments

**With Lifecycle:**

- Every PR gets its own isolated sandbox
- Zero setup - just open a PR
- Automatic cleanup when done
- Instant previews with shareable URLs

## Quick Demo

<Iframe src="https://www.youtube.com/embed/ld9rWBPU3R8?si=ff-_y0lXTNOmRxdT" />

## Next Steps

Ready to get started? See the [Setup Guide](/docs/setup) to install Lifecycle in your cluster.
